; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\weightsensor.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\weightsensor.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -IC:\Users\gchh\AppData\Local\Arm\Packs\Keil\SC32F1xxx_DFP\1.1.7\Device\SC32F12xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=543 -DSC32f12xx -DSC32f12xx -DPrintfEable --omf_browse=..\output\weightsensor.crf ..\Apps\WeightSensor.c]
                          THUMB

                          AREA ||i.Get_Tare||, CODE, READONLY, ALIGN=2

                  Get_Tare PROC
;;;50     
;;;51     float Get_Tare(void)//获取皮重
000000  b5f8              PUSH     {r3-r7,lr}
;;;52     {
;;;53     	uint32_t hx711_dat;
;;;54     	uint8_t i;
;;;55     	for(i=0;i<MEDIAN_LEN;i++)
000002  2400              MOVS     r4,#0
;;;56     	{
;;;57     		hx711_dat=Read_HX711();	        	//HX711AD转换数据处理
;;;58     		if(medleng == 0)                    //缓存的第1个元素,直接放入,不需要排序
;;;59     		{ 
;;;60     			buffer[0] = hx711_dat; medleng = 1; 
000004  4e20              LDR      r6,|L1.136|
                  |L1.6|
000006  f7fffffe          BL       Read_HX711
00000a  4b20              LDR      r3,|L1.140|
00000c  4605              MOV      r5,r0                 ;57
00000e  6818              LDR      r0,[r3,#0]            ;58  ; medleng
000010  2800              CMP      r0,#0                 ;58
000012  d001              BEQ      |L1.24|
;;;61     		}
;;;62     		else                            	//插入排序算法,按从小到大的顺序排列 
;;;63     		{  
;;;64     			for(i = 0; i < medleng; i ++)  
000014  2400              MOVS     r4,#0
000016  e00c              B        |L1.50|
                  |L1.24|
000018  2001              MOVS     r0,#1                 ;60
00001a  6035              STR      r5,[r6,#0]            ;60  ; buffer
00001c  e013              B        |L1.70|
                  |L1.30|
;;;65     			{
;;;66     				if( buffer[i] > hx711_dat) 	// 轮询到的当前元素>AD值,则交换它们的值，xd为中间变量存放位置
00001e  00a2              LSLS     r2,r4,#2
000020  58b1              LDR      r1,[r6,r2]
000022  42a9              CMP      r1,r5
000024  d903              BLS      |L1.46|
;;;67     				{ 
;;;68     					xd = hx711_dat; hx711_dat = buffer[i]; buffer[i] = xd;
000026  462f              MOV      r7,r5
000028  609d              STR      r5,[r3,#8]  ; xd
00002a  460d              MOV      r5,r1
00002c  50b7              STR      r7,[r6,r2]
                  |L1.46|
00002e  1c64              ADDS     r4,r4,#1
000030  b2e4              UXTB     r4,r4                 ;64
                  |L1.50|
000032  4284              CMP      r4,r0                 ;64
000034  dbf3              BLT      |L1.30|
;;;69     				}
;;;70     			}
;;;71     			buffer[medleng] = hx711_dat; 	//把轮询出较大的数放入缓存的后面.
000036  0081              LSLS     r1,r0,#2
000038  1c40              ADDS     r0,r0,#1
00003a  5075              STR      r5,[r6,r1]
;;;72     			medleng++;
;;;73     		}		
;;;74     		if(medleng >= MEDIAN_LEN) 		    //ADC采样的数据个数达到中值滤波要求的数据个数
00003c  6018              STR      r0,[r3,#0]  ; medleng
00003e  2805              CMP      r0,#5
000040  db02              BLT      |L1.72|
;;;75     		{
;;;76     			hx711_dat = buffer[MEDIAN];	    //最终重量取中值滤波数组的中间值
;;;77     			medleng = 0; 
000042  68f5              LDR      r5,[r6,#0xc]  ; buffer
000044  2000              MOVS     r0,#0
                  |L1.70|
000046  6018              STR      r0,[r3,#0]            ;60  ; medleng
                  |L1.72|
000048  1c64              ADDS     r4,r4,#1              ;60
00004a  b2e4              UXTB     r4,r4                 ;55
00004c  2c05              CMP      r4,#5                 ;55
00004e  d3da              BCC      |L1.6|
;;;78     		}
;;;79     	}
;;;80     	pi_weight=((float)hx711_dat/8388607.0)*1000*hx711_xishu;
000050  4f0e              LDR      r7,|L1.140|
000052  6878              LDR      r0,[r7,#4]  ; hx711_xishu
000054  f7fffffe          BL       __aeabi_f2d
000058  4604              MOV      r4,r0
00005a  460e              MOV      r6,r1
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       __aeabi_ui2f
000062  f7fffffe          BL       __aeabi_f2d
000066  2203              MOVS     r2,#3
000068  0792              LSLS     r2,r2,#30
00006a  4b09              LDR      r3,|L1.144|
00006c  f7fffffe          BL       __aeabi_ddiv
000070  2200              MOVS     r2,#0
000072  4b08              LDR      r3,|L1.148|
000074  f7fffffe          BL       __aeabi_dmul
000078  4622              MOV      r2,r4
00007a  4633              MOV      r3,r6
00007c  f7fffffe          BL       __aeabi_dmul
000080  f7fffffe          BL       __aeabi_d2f
000084  6178              STR      r0,[r7,#0x14]  ; pi_weight
;;;81     //	pi_weight *= hx711_xishu;
;;;82     	return pi_weight;
;;;83     }
000086  bdf8              POP      {r3-r7,pc}
;;;84     /*
                          ENDP

                  |L1.136|
                          DCD      ||.bss||
                  |L1.140|
                          DCD      ||.data||
                  |L1.144|
                          DCD      0x415fffff
                  |L1.148|
                          DCD      0x408f4000

                          AREA ||i.Get_Weight||, CODE, READONLY, ALIGN=2

                  Get_Weight PROC
;;;106    
;;;107    float Get_Weight(float pi_weight)	  //获取被测物体重量
000000  b5f1              PUSH     {r0,r4-r7,lr}
;;;108    {
;;;109    	uint32_t hx711_data,a;
;;;110    	float get,aa;	
;;;111    	hx711_data=Read_HX711();		   //HX711数据采集函数
;;;112    	get=((float)hx711_data/8388607.0)*1000*hx711_xishu;   //HX711AD转换数据处理，数据缩小100倍
000002  4c23              LDR      r4,|L2.144|
000004  f7fffffe          BL       Read_HX711
000008  4607              MOV      r7,r0                 ;111
00000a  6860              LDR      r0,[r4,#4]  ; hx711_xishu
00000c  f7fffffe          BL       __aeabi_f2d
000010  4605              MOV      r5,r0
000012  460e              MOV      r6,r1
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       __aeabi_ui2f
00001a  f7fffffe          BL       __aeabi_f2d
00001e  2203              MOVS     r2,#3
000020  0792              LSLS     r2,r2,#30
000022  4b1c              LDR      r3,|L2.148|
000024  f7fffffe          BL       __aeabi_ddiv
000028  2200              MOVS     r2,#0
00002a  4b1b              LDR      r3,|L2.152|
00002c  f7fffffe          BL       __aeabi_dmul
000030  462a              MOV      r2,r5
000032  4633              MOV      r3,r6
000034  f7fffffe          BL       __aeabi_dmul
000038  f7fffffe          BL       __aeabi_d2f
00003c  4601              MOV      r1,r0
;;;113    	if(get>pi_weight)
00003e  9800              LDR      r0,[sp,#0]
000040  f7fffffe          BL       __aeabi_cfcmple
000044  d221              BCS      |L2.138|
;;;114    	{
;;;115    		
;;;116    		a=Read_HX711();			   //重新采集HX711数据					 														   
000046  f7fffffe          BL       Read_HX711
00004a  4607              MOV      r7,r0
;;;117    		aa=((float)a/8388607.0)*1000*hx711_xishu;			     //测得的重量值减去皮重
00004c  6860              LDR      r0,[r4,#4]  ; hx711_xishu
00004e  f7fffffe          BL       __aeabi_f2d
000052  4605              MOV      r5,r0
000054  460e              MOV      r6,r1
000056  4638              MOV      r0,r7
000058  f7fffffe          BL       __aeabi_ui2f
00005c  f7fffffe          BL       __aeabi_f2d
000060  2203              MOVS     r2,#3
000062  0792              LSLS     r2,r2,#30
000064  4b0b              LDR      r3,|L2.148|
000066  f7fffffe          BL       __aeabi_ddiv
00006a  2200              MOVS     r2,#0
00006c  4b0a              LDR      r3,|L2.152|
00006e  f7fffffe          BL       __aeabi_dmul
000072  4633              MOV      r3,r6
000074  462a              MOV      r2,r5
000076  f7fffffe          BL       __aeabi_dmul
00007a  f7fffffe          BL       __aeabi_d2f
00007e  4601              MOV      r1,r0
;;;118    		weight=aa-pi_weight;//重量转换函数，传感器型号不同此函数要适当修改（修改HX711_xishu的大小）
000080  9800              LDR      r0,[sp,#0]
000082  f7fffffe          BL       __aeabi_frsub
;;;119    		later_weight=weight;
000086  60e0              STR      r0,[r4,#0xc]  ; weight
000088  e000              B        |L2.140|
                  |L2.138|
;;;120    	}
;;;121    	else				
;;;122    		later_weight=0;
00008a  2000              MOVS     r0,#0
                  |L2.140|
00008c  6120              STR      r0,[r4,#0x10]         ;119  ; later_weight
;;;123    	
;;;124    	return later_weight;
;;;125    }
00008e  bdf8              POP      {r3-r7,pc}
;;;126    
                          ENDP

                  |L2.144|
                          DCD      ||.data||
                  |L2.148|
                          DCD      0x415fffff
                  |L2.152|
                          DCD      0x408f4000

                          AREA ||i.HX711_Data_IN||, CODE, READONLY, ALIGN=2

                  HX711_Data_IN PROC
;;;134    
;;;135    uint8_t HX711_Data_IN(void)
000000  b510              PUSH     {r4,lr}
;;;136    {
;;;137    	return GPIO_ReadDataBit(HX711_DATA_GPIO_PORT,HX711_DATA_GPIO_PIN);
000002  2101              MOVS     r1,#1
000004  0309              LSLS     r1,r1,#12
000006  4802              LDR      r0,|L3.16|
000008  f7fffffe          BL       GPIO_ReadDataBit
;;;138    }
00000c  bd10              POP      {r4,pc}
;;;139    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40011100

                          AREA ||i.HX711_Data_In||, CODE, READONLY, ALIGN=2

                  HX711_Data_In PROC
;;;162    
;;;163    void HX711_Data_In(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;164    {
;;;165    	GPIO_InitTypeDef GPIO_InitStructure;
;;;166    
;;;167    	GPIO_InitStructure.GPIO_Pin = HX711_DATA_GPIO_PIN;
000002  2001              MOVS     r0,#1
000004  0300              LSLS     r0,r0,#12
000006  4669              MOV      r1,sp
000008  8008              STRH     r0,[r1,#0]
;;;168    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_PU;
00000a  2001              MOVS     r0,#1
00000c  8048              STRH     r0,[r1,#2]
;;;169    	GPIO_Init(HX711_DATA_GPIO_PORT, &GPIO_InitStructure);
00000e  4802              LDR      r0,|L4.24|
000010  f7fffffe          BL       GPIO_Init
;;;170    	
;;;171    }
000014  bd1c              POP      {r2-r4,pc}
;;;172    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0x40011100

                          AREA ||i.HX711_Data_Out||, CODE, READONLY, ALIGN=2

                  HX711_Data_Out PROC
;;;153    
;;;154    void HX711_Data_Out(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;155    {
;;;156    	GPIO_InitTypeDef GPIO_InitStructure;
;;;157    
;;;158    	GPIO_InitStructure.GPIO_Pin = HX711_DATA_GPIO_PIN;	
000002  2001              MOVS     r0,#1
000004  0300              LSLS     r0,r0,#12
000006  4669              MOV      r1,sp
000008  8008              STRH     r0,[r1,#0]
;;;159    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT_PP;
00000a  2002              MOVS     r0,#2
00000c  8048              STRH     r0,[r1,#2]
;;;160    	GPIO_Init(HX711_DATA_GPIO_PORT, &GPIO_InitStructure);
00000e  4802              LDR      r0,|L5.24|
000010  f7fffffe          BL       GPIO_Init
;;;161    }
000014  bd1c              POP      {r2-r4,pc}
;;;162    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      0x40011100

                          AREA ||i.HX711_GPIO_Init||, CODE, READONLY, ALIGN=2

                  HX711_GPIO_Init PROC
;;;139    
;;;140    void HX711_GPIO_Init(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;141    {
;;;142    	GPIO_InitTypeDef GPIO_InitStructure;
;;;143    	
;;;144    
;;;145    	GPIO_InitStructure.GPIO_Pin = HX711_SCK_GPIO_PIN;	
000002  2001              MOVS     r0,#1
000004  02c0              LSLS     r0,r0,#11
000006  466a              MOV      r2,sp
000008  8010              STRH     r0,[r2,#0]
;;;146    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT_PP;
00000a  2002              MOVS     r0,#2
;;;147    	GPIO_Init(HX711_SCK_GPIO_PORT, &GPIO_InitStructure);
00000c  4c07              LDR      r4,|L6.44|
00000e  8050              STRH     r0,[r2,#2]            ;146
000010  4669              MOV      r1,sp
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_Init
;;;148    	
;;;149    	GPIO_InitStructure.GPIO_Pin = HX711_DATA_GPIO_PIN;
000018  14a1              ASRS     r1,r4,#18
00001a  466a              MOV      r2,sp
00001c  8011              STRH     r1,[r2,#0]
;;;150    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_PU;
00001e  2101              MOVS     r1,#1
000020  8051              STRH     r1,[r2,#2]
;;;151    	GPIO_Init(HX711_DATA_GPIO_PORT, &GPIO_InitStructure);
000022  4669              MOV      r1,sp
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       GPIO_Init
;;;152    }
00002a  bd1c              POP      {r2-r4,pc}
;;;153    
                          ENDP

                  |L6.44|
                          DCD      0x40011100

                          AREA ||i.Read_HX711||, CODE, READONLY, ALIGN=2

                  Read_HX711 PROC
;;;172    
;;;173    uint32_t Read_HX711(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;174    {
;;;175    	uint8_t i;
;;;176    	uint32_t value = 0;
000002  2400              MOVS     r4,#0
;;;177    	
;;;178    	/**
;;;179    	数据手册写到，当数据输出管脚 DOUT 为高电平时，表明A/D 转换器还未准备好输出数据，此时串口时
;;;180    	钟输入信号 PD_SCK 应为低电平，所以下面设置引脚状态。
;;;181    	**/
;;;182    	HX711_Data_Out();
000004  f7fffffe          BL       HX711_Data_Out
;;;183    	HX711_DATA(1); //初始状态DT引脚为高电平
000008  4e26              LDR      r6,|L7.164|
00000a  2201              MOVS     r2,#1
00000c  0311              LSLS     r1,r2,#12
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       GPIO_WriteBit
;;;184    	delay_us(1);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       delay_us
;;;185    	HX711_SCK(0); //初始状态SCK引脚为低电平
00001a  14f7              ASRS     r7,r6,#19
00001c  2200              MOVS     r2,#0
00001e  4639              MOV      r1,r7
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       GPIO_WriteBit
;;;186    	HX711_Data_In();
000026  f7fffffe          BL       HX711_Data_In
                  |L7.42|
;;;187    	/**
;;;188    	等待DT引脚变为高电平
;;;189    	**/
;;;190    	while(HX711_Data_IN());
00002a  f7fffffe          BL       HX711_Data_IN
00002e  2800              CMP      r0,#0
000030  d1fb              BNE      |L7.42|
;;;191    	delay_us(1);
000032  2001              MOVS     r0,#1
000034  f7fffffe          BL       delay_us
;;;192    	
;;;193    	/**
;;;194    	当 DOUT 从高电平变低电平后，PD_SCK 应输入 25 至 27 个不等的时钟脉冲
;;;195    	25个时钟脉冲 ---> 通道A 增益128
;;;196    	26个时钟脉冲 ---> 通道B 增益32
;;;197    	27个时钟脉冲 ---> 通道A 增益64
;;;198    	**/
;;;199    	for(i=0; i<24; i++) //24位输出数据从最高位至最低位逐位输出完成
000038  2500              MOVS     r5,#0
                  |L7.58|
;;;200    	{
;;;201    		HX711_SCK(1);
00003a  2201              MOVS     r2,#1
00003c  4639              MOV      r1,r7
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       GPIO_WriteBit
;;;202    		delay_us(1);
000044  2001              MOVS     r0,#1
000046  f7fffffe          BL       delay_us
;;;203    		HX711_SCK(0);
00004a  2200              MOVS     r2,#0
00004c  4639              MOV      r1,r7
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       GPIO_WriteBit
;;;204    		if(HX711_Data_IN() == 0)
000054  f7fffffe          BL       HX711_Data_IN
000058  2800              CMP      r0,#0
00005a  d100              BNE      |L7.94|
;;;205    		{
;;;206    			value = value << 1;
00005c  0064              LSLS     r4,r4,#1
                  |L7.94|
;;;207    			value |= 0x00;
;;;208    		}
;;;209    		if(HX711_Data_IN() == 1)
00005e  f7fffffe          BL       HX711_Data_IN
000062  2801              CMP      r0,#1
000064  d101              BNE      |L7.106|
;;;210    		{
;;;211    			value = value << 1;
000066  0064              LSLS     r4,r4,#1
;;;212    			value |= 0x01;
000068  4304              ORRS     r4,r4,r0
                  |L7.106|
;;;213    		}
;;;214    		delay_us(1);
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       delay_us
000070  1c6d              ADDS     r5,r5,#1
000072  b2ed              UXTB     r5,r5                 ;199
000074  2d18              CMP      r5,#0x18              ;199
000076  d3e0              BCC      |L7.58|
;;;215    	}
;;;216    	
;;;217    	//第 25至 27 个时钟脉冲用来选择下一次 A/D 转换的输入通道和增益
;;;218    	HX711_SCK(1);; 
000078  2201              MOVS     r2,#1
00007a  4639              MOV      r1,r7
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       GPIO_WriteBit
;;;219    	value = value^0x800000; 
000082  2001              MOVS     r0,#1
000084  05c0              LSLS     r0,r0,#23
000086  4044              EORS     r4,r4,r0
;;;220    	delay_us(1); 
000088  2001              MOVS     r0,#1
00008a  f7fffffe          BL       delay_us
;;;221    	HX711_SCK(0); 
00008e  2200              MOVS     r2,#0
000090  4639              MOV      r1,r7
000092  4630              MOV      r0,r6
000094  f7fffffe          BL       GPIO_WriteBit
;;;222    	delay_us(1);  
000098  2001              MOVS     r0,#1
00009a  f7fffffe          BL       delay_us
;;;223    	return value; 	
00009e  4620              MOV      r0,r4
;;;224    }
0000a0  bdf8              POP      {r3-r7,pc}
                          ENDP

0000a2  0000              DCW      0x0000
                  |L7.164|
                          DCD      0x40011100

                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;126    
;;;127    void delay_us(int xus)
000000  2200              MOVS     r2,#0
;;;128    {
;;;129    	for (int i = 0; i < xus; i++) {
;;;130    		for (int j = 0; j < 5000; j++) {
000002  4b05              LDR      r3,|L8.24|
000004  e004              B        |L8.16|
                  |L8.6|
000006  2100              MOVS     r1,#0
                  |L8.8|
000008  1c49              ADDS     r1,r1,#1
00000a  4299              CMP      r1,r3
00000c  dbfc              BLT      |L8.8|
00000e  1c52              ADDS     r2,r2,#1
                  |L8.16|
000010  4282              CMP      r2,r0                 ;129
000012  dbf8              BLT      |L8.6|
;;;131    		}
;;;132    	}
;;;133    }
000014  4770              BX       lr
;;;134    
                          ENDP

000016  0000              DCW      0x0000
                  |L8.24|
                          DCD      0x00001388

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  buffer
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  medleng
                          DCD      0x00000000
                  hx711_xishu
000004  4145fa68          DCFS     0x4145fa68 ; 12.373634338378906
                  ||xd||
                          DCD      0x00000000
                  weight
                          DCD      0x00000000
                  later_weight
                          DCD      0x00000000
                  pi_weight
                          DCD      0x00000000

                          AREA ||area_number.13||, DATA, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.data||
                  xd1
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Apps\\WeightSensor.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_WeightSensor_c_medleng____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___14_WeightSensor_c_medleng____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_WeightSensor_c_medleng____REVSH|
#line 478
|__asm___14_WeightSensor_c_medleng____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
