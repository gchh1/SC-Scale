; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_uart.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_uart.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Algorithm -IC:\Users\gchh\AppData\Local\Arm\Packs\Keil\SC32F1xxx_DFP\1.1.7\Device\SC32F12xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=543 -DSC32f12xx -DSC32f12xx -DPrintfEable --omf_browse=..\output\sc32f1xxx_uart.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_uart.c]
                          THUMB

                          AREA ||i.LINCalChecksum||, CODE, READONLY, ALIGN=1

                  LINCalChecksum PROC
;;;664     */
;;;665    uint8_t LINCalChecksum ( uint8_t id, uint8_t *data, uint8_t len )
000000  b530              PUSH     {r4,r5,lr}
;;;666    {
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
;;;667        uint32_t sum = LIN_CalID ( id );
000006  f7fffffe          BL       LIN_CalID
;;;668        uint8_t i;
;;;669    
;;;670        for ( i = 0; i < len; i++ )
00000a  2300              MOVS     r3,#0
00000c  e008              B        |L1.32|
                  |L1.14|
;;;671        {
;;;672            sum += data[i];
00000e  5ce9              LDRB     r1,[r5,r3]
000010  1808              ADDS     r0,r1,r0
;;;673            if ( sum & 0xFF00 )
000012  0401              LSLS     r1,r0,#16
000014  0e09              LSRS     r1,r1,#24
000016  d001              BEQ      |L1.28|
;;;674            {
;;;675                sum = ( sum & 0x00FF ) + 1;
000018  b2c0              UXTB     r0,r0
00001a  1c40              ADDS     r0,r0,#1
                  |L1.28|
00001c  1c5b              ADDS     r3,r3,#1
00001e  b2db              UXTB     r3,r3                 ;670
                  |L1.32|
000020  42a3              CMP      r3,r4                 ;670
000022  d3f4              BCC      |L1.14|
;;;676            }
;;;677        }
;;;678    
;;;679        sum ^= 0x00FF;
000024  21ff              MOVS     r1,#0xff
000026  4048              EORS     r0,r0,r1
;;;680        return ( uint8_t ) sum;
000028  b2c0              UXTB     r0,r0
;;;681    }
00002a  bd30              POP      {r4,r5,pc}
;;;682    #endif
                          ENDP


                          AREA ||i.LIN_CalID||, CODE, READONLY, ALIGN=1

                  LIN_CalID PROC
;;;645     */
;;;646    uint8_t LIN_CalID ( uint8_t id )
000000  0841              LSRS     r1,r0,#1
;;;647    {
;;;648        uint8_t parity, p0, p1;
;;;649    
;;;650        parity = id;
;;;651        p0 = ( BIT ( parity, 0 ) ^ BIT ( parity, 1 ) ^ BIT ( parity, 2 ) ^ BIT ( parity, 4 ) ) << 6;
000002  460a              MOV      r2,r1
000004  4042              EORS     r2,r2,r0
000006  07d3              LSLS     r3,r2,#31
000008  0742              LSLS     r2,r0,#29
00000a  b510              PUSH     {r4,lr}               ;647
00000c  0fdb              LSRS     r3,r3,#31
00000e  0fd2              LSRS     r2,r2,#31
000010  4053              EORS     r3,r3,r2
000012  06c2              LSLS     r2,r0,#27
;;;652        p1 = ( ! ( BIT ( parity, 1 ) ^ BIT ( parity, 3 ) ^ BIT ( parity, 4 ) ^ BIT ( parity, 5 ) ) ) << 7;
000014  08c4              LSRS     r4,r0,#3
000016  0fd2              LSRS     r2,r2,#31             ;651
000018  4061              EORS     r1,r1,r4
00001a  07c9              LSLS     r1,r1,#31
00001c  4053              EORS     r3,r3,r2              ;651
00001e  0fc9              LSRS     r1,r1,#31
000020  4051              EORS     r1,r1,r2
000022  0682              LSLS     r2,r0,#26
000024  0fd2              LSRS     r2,r2,#31
000026  4051              EORS     r1,r1,r2
000028  2201              MOVS     r2,#1
00002a  019b              LSLS     r3,r3,#6              ;651
00002c  4051              EORS     r1,r1,r2
00002e  01c9              LSLS     r1,r1,#7
;;;653    
;;;654        parity |= ( p0 | p1 );
000030  430b              ORRS     r3,r3,r1
000032  4318              ORRS     r0,r0,r3
;;;655    
;;;656        return parity;
;;;657    }
000034  bd10              POP      {r4,pc}
;;;658    /**
                          ENDP


                          AREA ||i.Printf_UartInit||, CODE, READONLY, ALIGN=2

                  Printf_UartInit PROC
;;;713     */
;;;714    __attribute__((weak)) void Printf_UartInit ( UART_TypeDef* UARTx )
000000  4901              LDR      r1,|L3.8|
;;;715    {
;;;716    
;;;717        Printf_Uart = UARTx;
000002  6008              STR      r0,[r1,#0]  ; Printf_Uart
;;;718    }
000004  4770              BX       lr
;;;719    /*printf mapping function*/
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.data||

                          AREA ||i.UART_ClearFlag||, CODE, READONLY, ALIGN=1

                  UART_ClearFlag PROC
;;;454     */
;;;455    void UART_ClearFlag ( UART_TypeDef* UARTx, uint16_t UART_FLAG )
000000  6041              STR      r1,[r0,#4]
;;;456    {
;;;457        /* Check the parameters */
;;;458        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;459    
;;;460        /* Clear the flags */
;;;461        UARTx->UART_STS = ( uint16_t ) UART_FLAG;
;;;462    }
000002  4770              BX       lr
;;;463    
                          ENDP


                          AREA ||i.UART_DMACmd||, CODE, READONLY, ALIGN=1

                  UART_DMACmd PROC
;;;479     */
;;;480    void UART_DMACmd ( UART_TypeDef* UARTx, uint16_t UART_DMAReq, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;481    {
;;;482        /* Check the parameters */
;;;483        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;484        assert_param ( IS_UART_DMAREQ ( UART_DMAReq ) );
;;;485        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;486    
;;;487        if ( NewState != DISABLE )
;;;488        {
;;;489            /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;490               DMAR bits in the UART IDE register */
;;;491            UARTx->UART_IDE |= UART_DMAReq;
;;;492        }
;;;493        else
;;;494        {
;;;495            /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;496               DMAR bits in the UART IDE register */
;;;497            UARTx->UART_IDE &= ( uint16_t ) ~UART_DMAReq;
000002  6902              LDR      r2,[r0,#0x10]
000004  d001              BEQ      |L5.10|
000006  430a              ORRS     r2,r2,r1              ;491
000008  e002              B        |L5.16|
                  |L5.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L5.16|
000010  6102              STR      r2,[r0,#0x10]         ;491
;;;498        }
;;;499    }
000012  4770              BX       lr
;;;500    /* End of UART_Group3.	*/
                          ENDP


                          AREA ||i.UART_DeInit||, CODE, READONLY, ALIGN=2

                  UART_DeInit PROC
;;;51      */
;;;52     void UART_DeInit ( UART_TypeDef* UARTx )
000000  b510              PUSH     {r4,lr}
;;;53     {
000002  4604              MOV      r4,r0
;;;54         assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;55     
;;;56         if ( UARTx == UART0 )
000004  4824              LDR      r0,|L6.152|
000006  4284              CMP      r4,r0
000008  d106              BNE      |L6.24|
;;;57         {
;;;58             /* Enable UART0 reset state */
;;;59             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART0, ENABLE );
00000a  2101              MOVS     r1,#1
00000c  2040              MOVS     r0,#0x40
00000e  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;60             /* Release UART0 from reset state */
;;;61             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART0, DISABLE );
000012  2100              MOVS     r1,#0
000014  2040              MOVS     r0,#0x40
000016  e009              B        |L6.44|
                  |L6.24|
;;;62         }
;;;63         else if ( UARTx == UART1 )
000018  481f              LDR      r0,|L6.152|
00001a  3060              ADDS     r0,r0,#0x60
00001c  4284              CMP      r4,r0
00001e  d108              BNE      |L6.50|
;;;64         {
;;;65             /* Enable UART1 reset state */
;;;66             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART1, ENABLE );
000020  2101              MOVS     r1,#1
000022  2080              MOVS     r0,#0x80
000024  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;67             /* Release UART1 from reset state */
;;;68             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART1, DISABLE );
000028  2100              MOVS     r1,#0
00002a  2080              MOVS     r0,#0x80
                  |L6.44|
00002c  f7fffffe          BL       RCC_APB0PeriphResetCmd
000030  e016              B        |L6.96|
                  |L6.50|
;;;69         }
;;;70         else if ( UARTx == UART2 )
000032  481a              LDR      r0,|L6.156|
000034  4284              CMP      r4,r0
000036  d108              BNE      |L6.74|
;;;71         {
;;;72             /* Enable UART2 reset state */
;;;73             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART2, ENABLE );
000038  2101              MOVS     r1,#1
00003a  2080              MOVS     r0,#0x80
00003c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;74             /* Release UART2 from reset state */
;;;75             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART2, DISABLE );
000040  2100              MOVS     r1,#0
000042  2080              MOVS     r0,#0x80
000044  f7fffffe          BL       RCC_APB1PeriphResetCmd
000048  e00a              B        |L6.96|
                  |L6.74|
;;;76         }
;;;77         else if ( UARTx == UART3 )
00004a  4815              LDR      r0,|L6.160|
00004c  4284              CMP      r4,r0
00004e  d107              BNE      |L6.96|
;;;78         {
;;;79             /* Enable UART3 reset state */
;;;80             RCC_APB2PeriphResetCmd ( RCC_APB2Periph_UART3, ENABLE );
000050  2101              MOVS     r1,#1
000052  2004              MOVS     r0,#4
000054  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;81             /* Release UART3 from reset state */
;;;82             RCC_APB2PeriphResetCmd ( RCC_APB2Periph_UART3, DISABLE );
000058  2100              MOVS     r1,#0
00005a  2004              MOVS     r0,#4
00005c  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L6.96|
;;;83         }
;;;84     
;;;85     #if  defined(SC32f12xx)
;;;86         if ( UARTx == UART4 )
000060  480e              LDR      r0,|L6.156|
000062  3060              ADDS     r0,r0,#0x60
000064  4284              CMP      r4,r0
000066  d108              BNE      |L6.122|
;;;87         {
;;;88             /* Enable UART0 reset state */
;;;89             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART4, ENABLE );
000068  2101              MOVS     r1,#1
00006a  2040              MOVS     r0,#0x40
00006c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;90             /* Release UART0 from reset state */
;;;91             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART4, DISABLE );
000070  2100              MOVS     r1,#0
000072  2040              MOVS     r0,#0x40
000074  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L6.120|
;;;92         }
;;;93         else if ( UARTx == UART5 )
;;;94         {
;;;95             /* Enable UART5 reset state */
;;;96             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART5, ENABLE );
;;;97             /* Release UART5 from reset state */
;;;98             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART5, DISABLE );
;;;99         }
;;;100    #endif
;;;101    }
000078  bd10              POP      {r4,pc}
                  |L6.122|
00007a  4807              LDR      r0,|L6.152|
00007c  3080              ADDS     r0,r0,#0x80           ;93
00007e  4284              CMP      r4,r0                 ;93
000080  d1fa              BNE      |L6.120|
000082  1544              ASRS     r4,r0,#21             ;96
000084  2101              MOVS     r1,#1                 ;96
000086  4620              MOV      r0,r4                 ;96
000088  f7fffffe          BL       RCC_APB0PeriphResetCmd
00008c  2100              MOVS     r1,#0                 ;98
00008e  4620              MOV      r0,r4                 ;98
000090  f7fffffe          BL       RCC_APB0PeriphResetCmd
000094  bd10              POP      {r4,pc}
;;;102    
                          ENDP

000096  0000              DCW      0x0000
                  |L6.152|
                          DCD      0x40020020
                  |L6.156|
                          DCD      0x40021020
                  |L6.160|
                          DCD      0x40022020

                          AREA ||i.UART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  UART_GetFlagStatus PROC
;;;414     */
;;;415    FlagStatus UART_GetFlagStatus ( UART_TypeDef* UARTx, UART_FLAG_TypeDef UART_FLAG )
000000  4602              MOV      r2,r0
;;;416    {
;;;417        ITStatus bitstatus = RESET;
;;;418        /* Check the parameters */
;;;419        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;420        assert_param ( IS_GET_UART_FLAG ( UART_FLAG ) );
;;;421    
;;;422        if ( ( UARTx->UART_STS & UART_FLAG ) != ( uint16_t ) RESET )
000002  6852              LDR      r2,[r2,#4]
000004  2000              MOVS     r0,#0                 ;417
000006  420a              TST      r2,r1
000008  d000              BEQ      |L7.12|
;;;423        {
;;;424            bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L7.12|
;;;425        }
;;;426        else
;;;427        {
;;;428            bitstatus = RESET;
;;;429        }
;;;430        return bitstatus;
;;;431    }
00000c  4770              BX       lr
;;;432    
                          ENDP


                          AREA ||i.UART_ITConfig||, CODE, READONLY, ALIGN=1

                  UART_ITConfig PROC
;;;375     */
;;;376    void UART_ITConfig ( UART_TypeDef* UARTx, uint16_t UART_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;377    {
;;;378        /* Check the parameters */
;;;379        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;380        assert_param ( IS_UART_IT ( UART_IT ) );
;;;381        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;382    
;;;383        if ( NewState != DISABLE )
;;;384        {
;;;385            /* Enable the Interrupt sources */
;;;386            UARTx->UART_IDE |= UART_IT;
;;;387        }
;;;388        else
;;;389        {
;;;390            /* Disable the Interrupt sources */
;;;391            UARTx->UART_IDE &= ( uint16_t ) ~UART_IT;
000002  6902              LDR      r2,[r0,#0x10]
000004  d001              BEQ      |L8.10|
000006  430a              ORRS     r2,r2,r1              ;386
000008  e002              B        |L8.16|
                  |L8.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L8.16|
000010  6102              STR      r2,[r0,#0x10]         ;386
;;;392        }
;;;393    }
000012  4770              BX       lr
;;;394    
                          ENDP


                          AREA ||i.UART_Init||, CODE, READONLY, ALIGN=2

                  UART_Init PROC
;;;118     */
;;;119    void UART_Init ( UART_TypeDef* UARTx, UART_InitTypeDef* UART_InitStruct )
000000  b570              PUSH     {r4-r6,lr}
;;;120    {
000002  4604              MOV      r4,r0
;;;121        uint32_t tmpreg;
;;;122        /* Check the parameters */
;;;123        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;124        assert_param ( IS_UART_Mode ( UART_InitStruct->UART_Mode ) );
;;;125    
;;;126        tmpreg = UARTx->UART_CON;
000004  6800              LDR      r0,[r0,#0]
;;;127        tmpreg &= ( uint32_t ) ~ ( UART_CON_SM01 | UART_CON_SM2 );
;;;128        tmpreg |= ( uint32_t ) ( UART_InitStruct->UART_Mode );
000006  688a              LDR      r2,[r1,#8]
000008  08c0              LSRS     r0,r0,#3              ;127
00000a  00c0              LSLS     r0,r0,#3              ;127
00000c  4302              ORRS     r2,r2,r0
;;;129        UARTx->UART_CON = tmpreg;
00000e  6022              STR      r2,[r4,#0]
;;;130    
;;;131        if ( UART_InitStruct->UART_Mode == UART_Mode_8B )
000010  6888              LDR      r0,[r1,#8]
;;;132        {
;;;133            assert_param ( IS_UART_PRESCALER ( UART_InitStruct->UART_BaudRate ) );
;;;134    
;;;135            UARTx->UART_CON &= ~ ( uint32_t ) UART_CON_PERSCALER;
000012  2510              MOVS     r5,#0x10
000014  2800              CMP      r0,#0                 ;131
000016  d00c              BEQ      |L9.50|
000018  c905              LDM      r1!,{r0,r2}           ;120
00001a  4611              MOV      r1,r2                 ;120
;;;136            UARTx->UART_CON |= ( uint32_t ) UART_CON_PERSCALER;
;;;137        }
;;;138        else
;;;139        {
;;;140            tmpreg = ( UART_InitStruct->UART_ClockFrequency / UART_InitStruct->UART_BaudRate );
00001c  f7fffffe          BL       __aeabi_uidivmod
;;;141            if ( tmpreg > 65535 )
000020  4907              LDR      r1,|L9.64|
000022  4288              CMP      r0,r1
000024  d903              BLS      |L9.46|
;;;142            {
;;;143                UARTx->UART_CON |= ( uint32_t ) UART_CON_PERSCALER;
000026  6821              LDR      r1,[r4,#0]
000028  4329              ORRS     r1,r1,r5
00002a  6021              STR      r1,[r4,#0]
;;;144                tmpreg = tmpreg / 16;
00002c  0900              LSRS     r0,r0,#4
                  |L9.46|
;;;145            }
;;;146            UARTx->UART_BAUD = tmpreg;
00002e  60a0              STR      r0,[r4,#8]
;;;147        }
;;;148    }
000030  bd70              POP      {r4-r6,pc}
                  |L9.50|
000032  6820              LDR      r0,[r4,#0]            ;135
000034  43a8              BICS     r0,r0,r5              ;135
000036  6020              STR      r0,[r4,#0]            ;135
000038  6820              LDR      r0,[r4,#0]            ;136
00003a  4328              ORRS     r0,r0,r5              ;136
00003c  6020              STR      r0,[r4,#0]            ;136
00003e  bd70              POP      {r4-r6,pc}
;;;149    
                          ENDP

                  |L9.64|
                          DCD      0x0000ffff

                          AREA ||i.UART_LIN_BKSIZE||, CODE, READONLY, ALIGN=2

                  UART_LIN_BKSIZE PROC
;;;548     */
;;;549    void UART_LIN_BKSIZE ( UART_TypeDef* UARTx, UART_BKSIZE_TypeDef BKSIZE )
000000  4a05              LDR      r2,|L10.24|
;;;550    {
;;;551        uint32_t temp;
;;;552        /* Check the parameters */
;;;553        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;554        assert_param ( IS_UART_BKSIZE ( BKSIZE ) );
;;;555    
;;;556        if ( UARTx == UART2 )
000002  4290              CMP      r0,r2
000004  d107              BNE      |L10.22|
;;;557        {
;;;558            temp = UART2->UART_CON;
000006  4a04              LDR      r2,|L10.24|
000008  3a20              SUBS     r2,r2,#0x20
00000a  6a10              LDR      r0,[r2,#0x20]
;;;559            temp &= ~UART_CON_BKSIZE;
00000c  2301              MOVS     r3,#1
00000e  069b              LSLS     r3,r3,#26
000010  4398              BICS     r0,r0,r3
;;;560            temp |= BKSIZE;
000012  4308              ORRS     r0,r0,r1
;;;561            /**/
;;;562            UART2->UART_CON = temp;
000014  6210              STR      r0,[r2,#0x20]
                  |L10.22|
;;;563        }
;;;564    
;;;565    }
000016  4770              BX       lr
;;;566    
                          ENDP

                  |L10.24|
                          DCD      0x40021020

                          AREA ||i.UART_LIN_LBDL||, CODE, READONLY, ALIGN=2

                  UART_LIN_LBDL PROC
;;;620     */
;;;621    void UART_LIN_LBDL ( UART_TypeDef* UARTx, UART_LBDL_TypeDef LBDL )
000000  4a05              LDR      r2,|L11.24|
;;;622    {
;;;623        uint32_t temp;
;;;624        /* Check the parameters */
;;;625        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;626        assert_param ( IS_UART_LBDL ( LBDL ) );
;;;627    
;;;628        if ( UARTx == UART2 )
000002  4290              CMP      r0,r2
000004  d107              BNE      |L11.22|
;;;629        {
;;;630            temp = UART2->UART_CON;
000006  4a04              LDR      r2,|L11.24|
000008  3a20              SUBS     r2,r2,#0x20
00000a  6a10              LDR      r0,[r2,#0x20]
;;;631            temp &= ~UART_CON_LBDL;
00000c  2301              MOVS     r3,#1
00000e  049b              LSLS     r3,r3,#18
000010  4398              BICS     r0,r0,r3
;;;632            temp |= LBDL;
000012  4308              ORRS     r0,r0,r1
;;;633            UART2->UART_CON = temp;
000014  6210              STR      r0,[r2,#0x20]
                  |L11.22|
;;;634        }
;;;635    
;;;636    
;;;637    
;;;638    
;;;639    }
000016  4770              BX       lr
;;;640    
                          ENDP

                  |L11.24|
                          DCD      0x40021020

                          AREA ||i.UART_LIN_MODE||, CODE, READONLY, ALIGN=2

                  UART_LIN_MODE PROC
;;;524    
;;;525    void UART_LIN_MODE ( UART_TypeDef* UARTx, UART_LINMODE_TypeDef UART_LINMODE )
000000  4a05              LDR      r2,|L12.24|
;;;526    {
;;;527        uint32_t temp;
;;;528        /* Check the parameters */
;;;529        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;530        assert_param ( IS_UART_LINMODE ( UART_LINMODE ) );
;;;531    
;;;532        if ( UARTx == UART2 )
000002  4290              CMP      r0,r2
000004  d106              BNE      |L12.20|
;;;533        {
;;;534            temp = UART2->UART_CON;
000006  4a04              LDR      r2,|L12.24|
000008  3a20              SUBS     r2,r2,#0x20
00000a  6a10              LDR      r0,[r2,#0x20]
;;;535            temp &= ~ ( UART_CON_SLVEN | UART_CON_FUNCSEL );
00000c  4b03              LDR      r3,|L12.28|
00000e  4018              ANDS     r0,r0,r3
;;;536            temp |= UART_LINMODE;
000010  4308              ORRS     r0,r0,r1
;;;537            UART2->UART_CON = temp;
000012  6210              STR      r0,[r2,#0x20]
                  |L12.20|
;;;538        }
;;;539    }
000014  4770              BX       lr
;;;540    /**
                          ENDP

000016  0000              DCW      0x0000
                  |L12.24|
                          DCD      0x40021020
                  |L12.28|
                          DCD      0xfffefeff

                          AREA ||i.UART_LIN_SLVARENE||, CODE, READONLY, ALIGN=2

                  UART_LIN_SLVARENE PROC
;;;585     */
;;;586    void UART_LIN_SLVARENE ( UART_TypeDef* UARTx, FunctionalState NewState )
000000  4a07              LDR      r2,|L13.32|
;;;587    {
;;;588    
;;;589        /* Check the parameters */
;;;590        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;591    
;;;592        if ( UARTx == UART2 )
000002  4290              CMP      r0,r2
000004  d10a              BNE      |L13.28|
;;;593        {
;;;594            if ( NewState != DISABLE )
;;;595            {
;;;596                /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;597                   DMAR bits in the UART IDE register */
;;;598                UART2->UART_CON |= UART_CON_SLVAREN;
000006  4806              LDR      r0,|L13.32|
000008  2201              MOVS     r2,#1
00000a  3820              SUBS     r0,r0,#0x20
00000c  0452              LSLS     r2,r2,#17
00000e  2900              CMP      r1,#0                 ;594
;;;599            }
;;;600            else
;;;601            {
;;;602                /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;603                   DMAR bits in the UART IDE register */
;;;604                UART2->UART_CON &= ( uint32_t ) ~UART_CON_SLVAREN;
000010  6a01              LDR      r1,[r0,#0x20]
000012  d001              BEQ      |L13.24|
000014  4311              ORRS     r1,r1,r2              ;598
000016  e000              B        |L13.26|
                  |L13.24|
000018  4391              BICS     r1,r1,r2
                  |L13.26|
00001a  6201              STR      r1,[r0,#0x20]
                  |L13.28|
;;;605            }
;;;606    
;;;607    
;;;608        }
;;;609    
;;;610    }
00001c  4770              BX       lr
;;;611    
                          ENDP

00001e  0000              DCW      0x0000
                  |L13.32|
                          DCD      0x40021020

                          AREA ||i.UART_PinRemapConfig||, CODE, READONLY, ALIGN=1

                  UART_PinRemapConfig PROC
;;;308     */
;;;309    void UART_PinRemapConfig ( UART_TypeDef* UARTx, UART_PinRemap_TypeDef UART_Remap )
000000  6802              LDR      r2,[r0,#0]
;;;310    {
;;;311        uint32_t tmpreg;
;;;312    
;;;313        /* Check the parameters */
;;;314    #if defined(SC32f10xx)
;;;315        if ( UARTx == UART2 )
;;;316        {
;;;317            tmpreg = UARTx->UART_CON;
;;;318    
;;;319            tmpreg &= ( uint32_t ) ( ~UART_CON_SPOS );
;;;320    
;;;321            tmpreg |= UART_Remap;
;;;322    
;;;323            UARTx->UART_CON = tmpreg;
;;;324        }
;;;325    
;;;326    #elif defined(SC32f12xx)
;;;327        tmpreg = UARTx->UART_CON;
;;;328    
;;;329        tmpreg &= ( uint32_t ) ( ~UART_CON_SPOS );
000002  2303              MOVS     r3,#3
000004  039b              LSLS     r3,r3,#14
000006  439a              BICS     r2,r2,r3
;;;330    
;;;331        tmpreg |= UART_Remap;
000008  430a              ORRS     r2,r2,r1
;;;332    
;;;333        UARTx->UART_CON = tmpreg;
00000a  6002              STR      r2,[r0,#0]
;;;334    #endif
;;;335    }
00000c  4770              BX       lr
;;;336    
                          ENDP


                          AREA ||i.UART_RXCmd||, CODE, READONLY, ALIGN=2

                  UART_RXCmd PROC
;;;199     */
;;;200    void UART_RXCmd ( UART_TypeDef* UARTx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;201    {
;;;202        /* Check the parameters */
;;;203        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;204        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;205    
;;;206        if ( NewState != DISABLE )
;;;207        {
;;;208            /* Enable the UART RX Function */
;;;209            UARTx->UART_CON |= UART_CON_RXEN;
;;;210        }
;;;211        else
;;;212        {
;;;213            /* Disable the UART RX Function */
;;;214            UARTx->UART_CON &= ( uint16_t ) ~UART_CON_RXEN;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L15.12|
000006  2240              MOVS     r2,#0x40              ;209
000008  4311              ORRS     r1,r1,r2              ;209
00000a  e001              B        |L15.16|
                  |L15.12|
00000c  4a01              LDR      r2,|L15.20|
00000e  4011              ANDS     r1,r1,r2
                  |L15.16|
000010  6001              STR      r1,[r0,#0]            ;209
;;;215        }
;;;216    }
000012  4770              BX       lr
;;;217    
                          ENDP

                  |L15.20|
                          DCD      0x0000ffbf

                          AREA ||i.UART_ReceiveData||, CODE, READONLY, ALIGN=1

                  UART_ReceiveData PROC
;;;268     */
;;;269    uint16_t UART_ReceiveData ( UART_TypeDef* UARTx )
000000  68c0              LDR      r0,[r0,#0xc]
;;;270    {
;;;271        /* Check the parameters */
;;;272        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;273    
;;;274        /* Receive Data */
;;;275        return ( uint16_t ) ( UARTx->UART_DATA & ( uint16_t ) 0x01FF );
000002  05c0              LSLS     r0,r0,#23
000004  0dc0              LSRS     r0,r0,#23
;;;276    }
000006  4770              BX       lr
;;;277    
                          ENDP


                          AREA ||i.UART_SendBreak||, CODE, READONLY, ALIGN=2

                  UART_SendBreak PROC
;;;570     */
;;;571    void UART_SendBreak()
000000  4803              LDR      r0,|L17.16|
;;;572    {
;;;573        UART2->UART_CON |= UART_CON_BKTR;
000002  6a01              LDR      r1,[r0,#0x20]
000004  2201              MOVS     r2,#1
000006  0612              LSLS     r2,r2,#24
000008  4311              ORRS     r1,r1,r2
00000a  6201              STR      r1,[r0,#0x20]
;;;574    }
00000c  4770              BX       lr
;;;575    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40021000

                          AREA ||i.UART_SendData||, CODE, READONLY, ALIGN=1

                  UART_SendData PROC
;;;246     */
;;;247    void UART_SendData ( UART_TypeDef* UARTx, uint16_t Data )
000000  05c9              LSLS     r1,r1,#23
;;;248    {
;;;249        /* Check the parameters */
;;;250        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;251    
;;;252        /* Transmit Data */
;;;253        UARTx->UART_DATA = ( Data & ( uint16_t ) 0x01FF );
000002  0dc9              LSRS     r1,r1,#23
000004  60c1              STR      r1,[r0,#0xc]
;;;254    }
000006  4770              BX       lr
;;;255    
                          ENDP


                          AREA ||i.UART_TXCmd||, CODE, READONLY, ALIGN=2

                  UART_TXCmd PROC
;;;165     */
;;;166    void UART_TXCmd ( UART_TypeDef* UARTx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;167    {
;;;168        /* Check the parameters */
;;;169        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;170        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;171    
;;;172        if ( NewState != DISABLE )
;;;173        {
;;;174            /* Enable the UART TX Function */
;;;175            UARTx->UART_CON |= UART_CON_TXEN;
;;;176        }
;;;177        else
;;;178        {
;;;179            /* Disable the UART TX Function */
;;;180            UARTx->UART_CON &= ( uint16_t ) ~UART_CON_TXEN;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L19.12|
000006  2280              MOVS     r2,#0x80              ;175
000008  4311              ORRS     r1,r1,r2              ;175
00000a  e001              B        |L19.16|
                  |L19.12|
00000c  4a01              LDR      r2,|L19.20|
00000e  4011              ANDS     r1,r1,r2
                  |L19.16|
000010  6001              STR      r1,[r0,#0]            ;175
;;;181        }
;;;182    }
000012  4770              BX       lr
;;;183    
                          ENDP

                  |L19.20|
                          DCD      0x0000ff7f

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;698    //    _sys_exit() Ա   ʹ ð     ģʽ
;;;699    void _sys_exit ( int x )
000000  4770              BX       lr
;;;700    {
;;;701        x = x;
;;;702    }
;;;703    #endif
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;720    #if defined (__ARMCC_VERSION)||defined (__ICCARM__)
;;;721    __attribute__((weak)) int fputc ( int c, FILE* f )
000000  b510              PUSH     {r4,lr}
;;;722    {
;;;723        UART_SendData ( Printf_Uart, ( uint8_t ) c );
000002  4b08              LDR      r3,|L21.36|
000004  4604              MOV      r4,r0                 ;722
000006  6819              LDR      r1,[r3,#0]            ;722  ; Printf_Uart
000008  b2c0              UXTB     r0,r0
00000a  60c8              STR      r0,[r1,#0xc]
                  |L21.12|
;;;724        while ( !UART_GetFlagStatus ( Printf_Uart, UART_Flag_TX ) );
00000c  2102              MOVS     r1,#2
00000e  6818              LDR      r0,[r3,#0]  ; Printf_Uart
000010  f7fffffe          BL       UART_GetFlagStatus
000014  2800              CMP      r0,#0
000016  d0f9              BEQ      |L21.12|
000018  6819              LDR      r1,[r3,#0]  ; Printf_Uart
;;;725        UART_ClearFlag ( Printf_Uart, UART_Flag_TX );
00001a  2002              MOVS     r0,#2
00001c  6048              STR      r0,[r1,#4]
;;;726        return c;
00001e  4620              MOV      r0,r4
;;;727    }
000020  bd10              POP      {r4,pc}
;;;728    #elif defined (__GNUC__)
                          ENDP

000022  0000              DCW      0x0000
                  |L21.36|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  Printf_Uart
                          DCD      0x00000000

                          AREA ||area_number.25||, DATA, ALIGN=2

                          EXPORTAS ||area_number.25||, ||.data||
                  __stdout
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_sc32f1xxx_uart_c_c95a8597____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___16_sc32f1xxx_uart_c_c95a8597____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_sc32f1xxx_uart_c_c95a8597____REVSH|
#line 478
|__asm___16_sc32f1xxx_uart_c_c95a8597____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
