; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_op.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_op.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Algorithm -IC:\Users\gchh\AppData\Local\Arm\Packs\Keil\SC32F1xxx_DFP\1.1.7\Device\SC32F12xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=543 -DSC32f12xx -DSC32f12xx -DPrintfEable --omf_browse=..\output\sc32f1xxx_op.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_op.c]
                          THUMB

                          AREA ||i.OP_Cmd||, CODE, READONLY, ALIGN=2

                  OP_Cmd PROC
;;;125     */
;;;126    void OP_Cmd ( OP_TypeDef* OPx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;127    {
;;;128    #if defined (SC32f12xx)
;;;129        /* Check the parameters */
;;;130        assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;131        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;132    
;;;133        if ( NewState != DISABLE )
;;;134        {
;;;135            /* Enable the OP Function */
;;;136            OPx->OP_CON |= OP_CON_ENOP;
;;;137        }
;;;138        else
;;;139        {
;;;140            /* Disable the OP Function */
;;;141            OPx->OP_CON &= ( uint16_t ) ~OP_CON_ENOP;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L1.12|
000006  2201              MOVS     r2,#1                 ;136
000008  4311              ORRS     r1,r1,r2              ;136
00000a  e001              B        |L1.16|
                  |L1.12|
00000c  4a01              LDR      r2,|L1.20|
00000e  4011              ANDS     r1,r1,r2
                  |L1.16|
000010  6001              STR      r1,[r0,#0]            ;136
;;;142        }
;;;143    
;;;144    #endif
;;;145    }
000012  4770              BX       lr
;;;146    
                          ENDP

                  |L1.20|
                          DCD      0x0000fffe

                          AREA ||i.OP_DeInit||, CODE, READONLY, ALIGN=2

                  OP_DeInit PROC
;;;48      */
;;;49     void OP_DeInit ( OP_TypeDef* OPx )
000000  4903              LDR      r1,|L2.16|
;;;50     {
;;;51     #if defined (SC32f12xx) 
;;;52         uint32_t tmpreg;
;;;53         /* Check the parameters */
;;;54         assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;55     
;;;56         if ( OPx == OP )
000002  4288              CMP      r0,r1
000004  d102              BNE      |L2.12|
;;;57         {
;;;58             /* Get the OPx OP_CON value */
;;;59             tmpreg = OPx->OP_CON;
000006  6801              LDR      r1,[r0,#0]
;;;60     
;;;61             /* Set OPFS bit to OP_FreqSelect value */
;;;62             tmpreg &= 0x00000000;
000008  2100              MOVS     r1,#0
;;;63     
;;;64             /* Write to OPx OP_CON */
;;;65             OPx->OP_CON = ( uint32_t ) tmpreg;
00000a  6001              STR      r1,[r0,#0]
                  |L2.12|
;;;66         }
;;;67     
;;;68     #endif
;;;69     }
00000c  4770              BX       lr
;;;70     
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40022140

                          AREA ||i.OP_GainSelection||, CODE, READONLY, ALIGN=1

                  OP_GainSelection PROC
;;;199      */
;;;200    void OP_GainSelection ( OP_TypeDef* OPx, OP_PGAGain_TypeDef PGAGain )
000000  6802              LDR      r2,[r0,#0]
;;;201    {
;;;202    #if defined (SC32f12xx)
;;;203        /* Check the parameters */
;;;204        assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;205        assert_param ( IS_OP_PGAGain ( PGAGain ) );
;;;206    
;;;207    
;;;208        OPx->OP_CON &= ~ ( OP_CON_PGAGAIN );
000002  2303              MOVS     r3,#3
000004  021b              LSLS     r3,r3,#8
000006  439a              BICS     r2,r2,r3
000008  6002              STR      r2,[r0,#0]
;;;209        OPx->OP_CON |= PGAGain;
00000a  6802              LDR      r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  6002              STR      r2,[r0,#0]
;;;210    
;;;211    #endif
;;;212    
;;;213    }
000010  4770              BX       lr
;;;214    
                          ENDP


                          AREA ||i.OP_Init||, CODE, READONLY, ALIGN=2

                  OP_Init PROC
;;;82      */
;;;83     void OP_Init ( OP_TypeDef* OPx, OP_InitTypeDef* OP_InitStruct )
000000  b530              PUSH     {r4,r5,lr}
;;;84     {
;;;85     #if defined (SC32f12xx)
;;;86         uint32_t tmpreg;
;;;87         /* Check the parameters */
;;;88         assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;89         assert_param ( IS_OP_Output ( Output ) );
;;;90         assert_param ( IS_OP_Negative ( Negative ) );
;;;91         assert_param ( IS_OP_Posittive ( Posittive ) );
;;;92         assert_param ( IS_OP_PGAGain ( PGAGain ) );
;;;93         assert_param ( IS_OP_FDBResisrance ( FDBResisrance ) );
;;;94         assert_param ( IS_OP_ShortCircuit ( ShortCircuit ) );
;;;95     
;;;96         /*---------------------------- OPx OP_CON Configuration ------------------------*/
;;;97         /* Get the OPx OP_CON value */
;;;98         tmpreg = OPx->OP_CON;
000002  6802              LDR      r2,[r0,#0]
;;;99     
;;;100        /* Clear OPFS bits */
;;;101        tmpreg &= ( uint32_t ) ~ ( OP_CON_OPOSEL | OP_CON_OPNSEL | OP_CON_OPPSEL
000004  4b07              LDR      r3,|L4.36|
;;;102                                   | OP_CON_PGAGAIN | OP_CON_FDBRSEL | OP_CON_PGAOFC );
;;;103        /* Set OPFS bit to OP_FreqSelect value */
;;;104        tmpreg |= ( uint32_t ) ( OP_InitStruct->OP_FDBResisrance | OP_InitStruct->OP_Negative | OP_InitStruct->OP_Output |
000006  894c              LDRH     r4,[r1,#0xa]
000008  401a              ANDS     r2,r2,r3              ;101
00000a  888b              LDRH     r3,[r1,#4]
00000c  88cd              LDRH     r5,[r1,#6]
00000e  4323              ORRS     r3,r3,r4
000010  898c              LDRH     r4,[r1,#0xc]
000012  432c              ORRS     r4,r4,r5
000014  4323              ORRS     r3,r3,r4
000016  890c              LDRH     r4,[r1,#8]
000018  6809              LDR      r1,[r1,#0]
00001a  4323              ORRS     r3,r3,r4
00001c  430b              ORRS     r3,r3,r1
00001e  4313              ORRS     r3,r3,r2
;;;105                                 OP_InitStruct->OP_PGAGain | OP_InitStruct->OP_Posittive | OP_InitStruct->OP_ShortCircuit );
;;;106    
;;;107        /* Write to OPx OP_CON */
;;;108        OPx->OP_CON = tmpreg;
000020  6003              STR      r3,[r0,#0]
;;;109    
;;;110    #endif
;;;111    }
000022  bd30              POP      {r4,r5,pc}
;;;112    
                          ENDP

                  |L4.36|
                          DCD      0xff7fcc15

                          AREA ||i.OP_OffsetSet||, CODE, READONLY, ALIGN=2

                  OP_OffsetSet PROC
;;;250     */
;;;251    ErrorStatus OP_OffsetSet(OP_TypeDef* OPx)
000000  b5f0              PUSH     {r4-r7,lr}
;;;252    {
;;;253    		uint8_t OPx_Readoffset0,OPx_Readoffset1,OPx_Readoffset2,OPx_Readoffset3;
;;;254    	  uint16_t OPx_offsetchecksum0,OPx_offsetchecksum1;
;;;255    	  OPx_Readoffset0 =  *((uint8_t *)0X08C00000+0x480);
000002  490f              LDR      r1,|L5.64|
000004  780b              LDRB     r3,[r1,#0]
;;;256    	  OPx_Readoffset1 =  *((uint8_t *)0X08C00000+0x481);
000006  784d              LDRB     r5,[r1,#1]
;;;257    	  OPx_Readoffset2 =  *((uint8_t *)0X08C00000+0x482);
000008  788c              LDRB     r4,[r1,#2]
;;;258    	  OPx_Readoffset3 =  *((uint8_t *)0X08C00000+0x483);
00000a  78ca              LDRB     r2,[r1,#3]
;;;259    	  OPx_offsetchecksum0 = (*((uint8_t *)0X08C00000+0x480))+(*((uint8_t *)0X08C00000+0x481))+(*((uint8_t *)0X08C00000+0x482))+(*((uint8_t *)0X08C00000+0x483));
00000c  195e              ADDS     r6,r3,r5
00000e  18a7              ADDS     r7,r4,r2
000010  19f7              ADDS     r7,r6,r7
;;;260    	  OPx_offsetchecksum1 = ((*((uint8_t *)0X08C00000+0x484))<<8)|(*((uint8_t *)0X08C00000+0x485));
000012  790e              LDRB     r6,[r1,#4]
000014  7949              LDRB     r1,[r1,#5]
000016  0236              LSLS     r6,r6,#8
000018  430e              ORRS     r6,r6,r1
;;;261        if (( OPx_Readoffset0==0x55 )&&( OPx_Readoffset2==0x55 )&&(OPx_offsetchecksum0==OPx_offsetchecksum1))
00001a  2b55              CMP      r3,#0x55
00001c  d10d              BNE      |L5.58|
00001e  2c55              CMP      r4,#0x55
000020  d10b              BNE      |L5.58|
000022  42b7              CMP      r7,r6
000024  d109              BNE      |L5.58|
;;;262        {
;;;263    	      uint32_t tmpreg = 0;
;;;264            /*!< Get the OPAMPx_CSR register value */
;;;265           tmpreg = OPx->OP_CON;
000026  6801              LDR      r1,[r0,#0]
;;;266    
;;;267           /*!< Clear the trimming bits */
;;;268           tmpreg &= ( uint32_t ) ~ ( ( OP_CON_TRIMOFFSETN | OP_CON_TRIMOFFSETP ) );
000028  4b06              LDR      r3,|L5.68|
;;;269    
;;;270           /*!< Configure the new trimming value */
;;;271           tmpreg |= ( uint32_t ) ( ( OPx_Readoffset3 << OP_CON_TRIMOFFSETN_Pos ) | ( OPx_Readoffset1 << OP_CON_TRIMOFFSETP_Pos ) );
00002a  0612              LSLS     r2,r2,#24
00002c  4019              ANDS     r1,r1,r3              ;268
00002e  042b              LSLS     r3,r5,#16
000030  431a              ORRS     r2,r2,r3
000032  430a              ORRS     r2,r2,r1
;;;272    
;;;273           /*!< Write to OPAMPx_CSR register */
;;;274            OPx->OP_CON = tmpreg;
000034  6002              STR      r2,[r0,#0]
;;;275            return SUCCESS;
000036  2000              MOVS     r0,#0
;;;276        }
;;;277        else
;;;278        {
;;;279            return ERROR;
;;;280        }
;;;281    }
000038  bdf0              POP      {r4-r7,pc}
                  |L5.58|
00003a  2001              MOVS     r0,#1                 ;279
00003c  bdf0              POP      {r4-r7,pc}
;;;282    
                          ENDP

00003e  0000              DCW      0x0000
                  |L5.64|
                          DCD      0x08c00480
                  |L5.68|
                          DCD      0xe0e0ffff

                          AREA ||i.OP_OffsetTrimConfig||, CODE, READONLY, ALIGN=2

                  OP_OffsetTrimConfig PROC
;;;158      */
;;;159    void OP_OffsetTrimConfig ( OP_TypeDef* OPx,  uint32_t OP_TrimValueH, uint32_t OP_TrimValueL )
000000  b510              PUSH     {r4,lr}
;;;160    {
;;;161    #if defined (SC32f12xx)
;;;162        uint32_t tmpreg = 0;
;;;163    
;;;164        /* Check the parameters */
;;;165        assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;166    
;;;167    
;;;168        /*!< Get the OPAMPx_CSR register value */
;;;169        tmpreg = OPx->OP_CON;
000002  6803              LDR      r3,[r0,#0]
;;;170    
;;;171        /*!< Clear the trimming bits */
;;;172        tmpreg &= ( uint32_t ) ~ ( ( OP_CON_TRIMOFFSETP | OP_CON_TRIMOFFSETN ) );
000004  4c03              LDR      r4,|L6.20|
;;;173    
;;;174        /*!< Configure the new trimming value */
;;;175        tmpreg |= ( uint32_t ) ( ( OP_TrimValueL << OP_CON_TRIMOFFSETP_Pos ) | ( OP_TrimValueH << OP_CON_TRIMOFFSETN_Pos ) );
000006  0412              LSLS     r2,r2,#16
000008  0609              LSLS     r1,r1,#24
00000a  4023              ANDS     r3,r3,r4              ;172
00000c  430a              ORRS     r2,r2,r1
00000e  431a              ORRS     r2,r2,r3
;;;176    
;;;177        /*!< Write to OPAMPx_CSR register */
;;;178        OPx->OP_CON = tmpreg;
000010  6002              STR      r2,[r0,#0]
;;;179    
;;;180    #endif
;;;181    }
000012  bd10              POP      {r4,pc}
;;;182    
                          ENDP

                  |L6.20|
                          DCD      0xe0e0ffff

                          AREA ||i.OP_OutputSelection||, CODE, READONLY, ALIGN=1

                  OP_OutputSelection PROC
;;;230      */
;;;231    void OP_OutputSelection ( OP_TypeDef* OPx, OP_Output_TypeDef OPOutput )
000000  6802              LDR      r2,[r0,#0]
;;;232    {
;;;233    #if defined (SC32f12xx)
;;;234        /* Check the parameters */
;;;235        assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;236        assert_param ( IS_OP_Output ( OPOutput ) );
;;;237    
;;;238    
;;;239        OPx->OP_CON &= ~ ( OP_CON_OPOSEL );
000002  2302              MOVS     r3,#2
000004  439a              BICS     r2,r2,r3
000006  6002              STR      r2,[r0,#0]
;;;240        OPx->OP_CON |= OPOutput;
000008  6802              LDR      r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;241    
;;;242    #endif
;;;243    }
00000e  4770              BX       lr
;;;244    #if defined (SC32f12xx)
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_op.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_sc32f1xxx_op_c_e58096f1____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___14_sc32f1xxx_op_c_e58096f1____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_sc32f1xxx_op_c_e58096f1____REVSH|
#line 478
|__asm___14_sc32f1xxx_op_c_e58096f1____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
