; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\key.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\key.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Algorithm -IC:\Users\gchh\AppData\Local\Arm\Packs\Keil\SC32F1xxx_DFP\1.1.7\Device\SC32F12xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=543 -DSC32f12xx -DSC32f12xx -DPrintfEable --omf_browse=..\output\key.crf ..\Apps\Key.c]
                          THUMB

                          AREA ||i.Key_Check||, CODE, READONLY, ALIGN=2

                  Key_Check PROC
;;;73      */
;;;74     uint8_t Key_Check(uint8_t key, uint8_t flag) {
000000  b510              PUSH     {r4,lr}
;;;75     	// 检查指定按键的指定标志位是否置位
;;;76     	if (Key_Flag[key] & flag) {
000002  4b06              LDR      r3,|L1.28|
000004  5c1a              LDRB     r2,[r3,r0]
000006  420a              TST      r2,r1
000008  d005              BEQ      |L1.22|
;;;77     		if (flag != KEY_HOLD) {
00000a  2901              CMP      r1,#1
00000c  d001              BEQ      |L1.18|
;;;78     			Key_Flag[key] &= ~flag;
00000e  438a              BICS     r2,r2,r1
000010  541a              STRB     r2,[r3,r0]
                  |L1.18|
;;;79     		}
;;;80     		return 1;
000012  2001              MOVS     r0,#1
;;;81     	}
;;;82     	return 0;
;;;83     }
000014  bd10              POP      {r4,pc}
                  |L1.22|
000016  2000              MOVS     r0,#0                 ;82
000018  bd10              POP      {r4,pc}
;;;84     
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      ||.data||+0x11

                          AREA ||i.Key_GetState||, CODE, READONLY, ALIGN=2

                  Key_GetState PROC
;;;41      */
;;;42     uint8_t Key_GetState(uint8_t key) {
000000  b510              PUSH     {r4,lr}
;;;43     	switch (key) {
;;;44     		case KEY_1: 
;;;45     			if (GPIO_ReadDataBit(Key_Port, Key1_Pin) == 0) {
000002  4a0f              LDR      r2,|L2.64|
000004  2801              CMP      r0,#1                 ;43
000006  d006              BEQ      |L2.22|
000008  2802              CMP      r0,#2                 ;43
00000a  d007              BEQ      |L2.28|
00000c  2803              CMP      r0,#3                 ;43
00000e  d00e              BEQ      |L2.46|
000010  2804              CMP      r0,#4                 ;43
000012  d10a              BNE      |L2.42|
000014  e00e              B        |L2.52|
                  |L2.22|
000016  2101              MOVS     r1,#1
000018  0289              LSLS     r1,r1,#10
00001a  e001              B        |L2.32|
                  |L2.28|
;;;46     				return KEY_PRESSED;
;;;47     			}
;;;48     			break;
;;;49     		case KEY_2: 
;;;50     			if (GPIO_ReadDataBit(Key_Port, Key2_Pin) == 0) {
00001c  2101              MOVS     r1,#1
00001e  02c9              LSLS     r1,r1,#11
                  |L2.32|
000020  4610              MOV      r0,r2                 ;45
000022  f7fffffe          BL       GPIO_ReadDataBit
000026  2800              CMP      r0,#0                 ;45
000028  d007              BEQ      |L2.58|
                  |L2.42|
;;;51     				return KEY_PRESSED;
;;;52     			}
;;;53     			break;
;;;54     		case KEY_3: 
;;;55     			if (GPIO_ReadDataBit(Key_Port, Key3_Pin) == 0) {
;;;56     				return KEY_PRESSED;
;;;57     			}
;;;58     			break;
;;;59     		case KEY_4: 
;;;60     			if (GPIO_ReadDataBit(Key_Port, Key4_Pin) == 0) {
;;;61     				return KEY_PRESSED;
;;;62     			}
;;;63     			break;
;;;64     	}
;;;65     	return KEY_UNPRESSED;
00002a  2000              MOVS     r0,#0
;;;66     }
00002c  bd10              POP      {r4,pc}
                  |L2.46|
00002e  2101              MOVS     r1,#1                 ;55
000030  0309              LSLS     r1,r1,#12             ;55
000032  e7f5              B        |L2.32|
                  |L2.52|
000034  2101              MOVS     r1,#1                 ;60
000036  0349              LSLS     r1,r1,#13             ;60
000038  e7f2              B        |L2.32|
                  |L2.58|
00003a  2001              MOVS     r0,#1                 ;61
00003c  bd10              POP      {r4,pc}
;;;67     
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      0x40011000

                          AREA ||i.Key_Init||, CODE, READONLY, ALIGN=2

                  Key_Init PROC
;;;12      */
;;;13     void Key_Init(void) {
000000  b57c              PUSH     {r2-r6,lr}
;;;14     	// Init the GPIO
;;;15     	GPIO_InitTypeDef GPIO_InitStructure;
;;;16     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_PU;
000002  2501              MOVS     r5,#1
000004  4668              MOV      r0,sp
000006  8045              STRH     r5,[r0,#2]
;;;17     	GPIO_InitStructure.GPIO_Pin = Key1_Pin;
000008  02a9              LSLS     r1,r5,#10
00000a  8001              STRH     r1,[r0,#0]
;;;18     	GPIO_InitStructure.GPIO_DriveLevel = 0;
00000c  2400              MOVS     r4,#0
;;;19     	GPIO_Init(Key_Port, &GPIO_InitStructure);
00000e  4e11              LDR      r6,|L3.84|
000010  8084              STRH     r4,[r0,#4]            ;18
000012  4669              MOV      r1,sp
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       GPIO_Init
;;;20     	
;;;21     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_PU;
00001a  4668              MOV      r0,sp
00001c  8045              STRH     r5,[r0,#2]
;;;22     	GPIO_InitStructure.GPIO_Pin = Key2_Pin;
00001e  02e9              LSLS     r1,r5,#11
000020  8001              STRH     r1,[r0,#0]
;;;23     	GPIO_InitStructure.GPIO_DriveLevel = 0;
000022  8084              STRH     r4,[r0,#4]
;;;24     	GPIO_Init(Key_Port, &GPIO_InitStructure);
000024  4669              MOV      r1,sp
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       GPIO_Init
;;;25     
;;;26     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_PU;
00002c  4668              MOV      r0,sp
00002e  8045              STRH     r5,[r0,#2]
;;;27     	GPIO_InitStructure.GPIO_Pin = Key3_Pin;
000030  0329              LSLS     r1,r5,#12
000032  8001              STRH     r1,[r0,#0]
;;;28     	GPIO_InitStructure.GPIO_DriveLevel = 0;
000034  8084              STRH     r4,[r0,#4]
;;;29     	GPIO_Init(Key_Port, &GPIO_InitStructure);
000036  4669              MOV      r1,sp
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       GPIO_Init
;;;30     
;;;31     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_PU;
00003e  4668              MOV      r0,sp
000040  8045              STRH     r5,[r0,#2]
;;;32     	GPIO_InitStructure.GPIO_Pin = Key4_Pin;
000042  0369              LSLS     r1,r5,#13
000044  8001              STRH     r1,[r0,#0]
;;;33     	GPIO_InitStructure.GPIO_DriveLevel = 0;
000046  8084              STRH     r4,[r0,#4]
;;;34     	GPIO_Init(Key_Port, &GPIO_InitStructure);
000048  4669              MOV      r1,sp
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       GPIO_Init
;;;35     }
000050  bd7c              POP      {r2-r6,pc}
;;;36     
                          ENDP

000052  0000              DCW      0x0000
                  |L3.84|
                          DCD      0x40011000

                          AREA ||i.Key_Tick||, CODE, READONLY, ALIGN=2

                  Key_Tick PROC
;;;88      */
;;;89     void Key_Tick(void) {
000000  b5f8              PUSH     {r3-r7,lr}
;;;90     	static uint8_t Count, i;						// Count: 扫描计数器, i: 循环变量
;;;91     	static uint8_t CurrState[KEY_COUNT], PrevState[KEY_COUNT];	// 当前状态和前一次状态
;;;92     	static uint8_t S[KEY_COUNT];					// 状态机状态数组
;;;93     	static uint16_t Time[KEY_COUNT];				// 定时器数组
;;;94     	// 所有按键的定时器递减
;;;95     	for (i = 0; i < KEY_COUNT; i++) {
000002  4b48              LDR      r3,|L4.292|
000004  2700              MOVS     r7,#0
;;;96     		Time[i] --;
000006  4c48              LDR      r4,|L4.296|
000008  705f              STRB     r7,[r3,#1]            ;95
                  |L4.10|
00000a  7858              LDRB     r0,[r3,#1]  ; i
00000c  0041              LSLS     r1,r0,#1
00000e  5a62              LDRH     r2,[r4,r1]
000010  1c40              ADDS     r0,r0,#1
000012  1e52              SUBS     r2,r2,#1
000014  b2c0              UXTB     r0,r0                 ;95
000016  5262              STRH     r2,[r4,r1]
000018  7058              STRB     r0,[r3,#1]            ;95
00001a  2805              CMP      r0,#5                 ;95
00001c  d3f5              BCC      |L4.10|
;;;97     	}
;;;98     	
;;;99     	// 每20ms扫描一次按键状态（假设本函数每1ms调用一次）
;;;100    	Count ++;
00001e  7818              LDRB     r0,[r3,#0]  ; Count
000020  1c40              ADDS     r0,r0,#1
000022  b2c0              UXTB     r0,r0
000024  7018              STRB     r0,[r3,#0]
;;;101    	if (Count >= 20) {
000026  2814              CMP      r0,#0x14
000028  d37b              BCC      |L4.290|
;;;102    		Count = 0;
;;;103    		// 遍历所有按键
;;;104    		for (i = 0; i < KEY_COUNT; i ++) {
;;;105    			// 更新按键状态
;;;106    			PrevState[i] = CurrState[i];
;;;107    			CurrState[i] = Key_GetState(i);
;;;108    
;;;109    			// 处理KEY_HOLD状态
;;;110    			if (CurrState[i] == KEY_PRESSED) {
;;;111    				Key_Flag[i] |= KEY_HOLD;		// 按键按下时置位HOLD标志
00002a  4d3e              LDR      r5,|L4.292|
00002c  701f              STRB     r7,[r3,#0]            ;102
00002e  705f              STRB     r7,[r3,#1]            ;104
000030  3511              ADDS     r5,r5,#0x11
                  |L4.50|
000032  493c              LDR      r1,|L4.292|
000034  4e3b              LDR      r6,|L4.292|
000036  1c89              ADDS     r1,r1,#2              ;106
000038  1e88              SUBS     r0,r1,#2              ;106
00003a  7840              LDRB     r0,[r0,#1]            ;106  ; i
00003c  1df6              ADDS     r6,r6,#7              ;106
00003e  5c09              LDRB     r1,[r1,r0]            ;106
000040  5431              STRB     r1,[r6,r0]            ;106
000042  f7fffffe          BL       Key_GetState
000046  1f72              SUBS     r2,r6,#5              ;107
000048  1e91              SUBS     r1,r2,#2              ;107
00004a  7849              LDRB     r1,[r1,#1]            ;107  ; i
00004c  2801              CMP      r0,#1                 ;110
00004e  5450              STRB     r0,[r2,r1]            ;107
;;;112    			}
;;;113    			else {
;;;114    				Key_Flag[i] &= ~KEY_HOLD;		// 按键松开时清除HOLD标志
000050  5c6a              LDRB     r2,[r5,r1]
000052  d005              BEQ      |L4.96|
000054  0852              LSRS     r2,r2,#1
000056  0052              LSLS     r2,r2,#1
000058  546a              STRB     r2,[r5,r1]
;;;115    			}
;;;116    
;;;117    			// 处理KEY_DOWN状态（上升沿检测）
;;;118    			if (CurrState[i] == KEY_PRESSED && PrevState[i] == KEY_UNPRESSED) {
;;;119    				Key_Flag[i] |= KEY_DOWN;
;;;120    			}
;;;121    
;;;122    			// 处理KEY_UP状态（下降沿检测）
;;;123    			if (CurrState[i] == KEY_UNPRESSED && PrevState[i] == KEY_PRESSED) {
00005a  2800              CMP      r0,#0
00005c  d008              BEQ      |L4.112|
00005e  e00d              B        |L4.124|
                  |L4.96|
000060  2301              MOVS     r3,#1                 ;111
000062  431a              ORRS     r2,r2,r3              ;111
000064  546a              STRB     r2,[r5,r1]            ;111
000066  5c73              LDRB     r3,[r6,r1]            ;118
000068  2b00              CMP      r3,#0                 ;118
00006a  d107              BNE      |L4.124|
00006c  2302              MOVS     r3,#2                 ;119
00006e  e003              B        |L4.120|
                  |L4.112|
000070  5c73              LDRB     r3,[r6,r1]
000072  2b01              CMP      r3,#1
000074  d102              BNE      |L4.124|
;;;124    				Key_Flag[i] |= KEY_UP;
000076  2304              MOVS     r3,#4
                  |L4.120|
000078  431a              ORRS     r2,r2,r3              ;119
00007a  546a              STRB     r2,[r5,r1]            ;119
                  |L4.124|
;;;125    			}
;;;126    
;;;127    			// 按键状态机处理
;;;128    			if (S[i] == 0) {	//* 状态0: 空闲状态
00007c  4b29              LDR      r3,|L4.292|
00007e  4e29              LDR      r6,|L4.292|
000080  330c              ADDS     r3,r3,#0xc
000082  5c5a              LDRB     r2,[r3,r1]
000084  2a00              CMP      r2,#0
000086  d008              BEQ      |L4.154|
;;;129    				if (CurrState[i] == KEY_PRESSED) {
;;;130    					Time[i] = KEY_TIME_LONG;	// 设置长按计时器
;;;131    					S[i] = 1;					// 转到状态1
;;;132    				}
;;;133    			} else if (S[i] == 1) { 	//* 状态1: 第一次按下状态
000088  2a01              CMP      r2,#1
00008a  d00e              BEQ      |L4.170|
;;;134    				if (CurrState[i] == KEY_UNPRESSED) {
;;;135    					Time[i] = KEY_TIME_DOUBLE;	// 设置双击检测计时器
;;;136    					S[i] = 2;					// 转到状态2
;;;137    				} else if (Time[i] == 0) {    // 长按时间到
;;;138    					Time[i] = KEY_TIME_REPEAT;	// 设置重复触发计时器
;;;139    					Key_Flag[i] |= KEY_LONG;	// 置位长按标志
;;;140    					S[i] = 4;					// 转到状态4
;;;141    				}
;;;142    			} else if (S[i] == 2) {		//* 状态2: 第一次松开状态
00008c  2a02              CMP      r2,#2
00008e  d01d              BEQ      |L4.204|
;;;143    				if (CurrState[i] == KEY_PRESSED) {
;;;144    					Key_Flag[i] |= KEY_DOUBLE;	// 置位双击标志
;;;145    					S[i] = 3;					// 转到状态3
;;;146    				} else if (Time[i] == 0) {		// 双击检测时间到
;;;147    					Key_Flag[i] |= KEY_SINGLE;	// 置位单击标志
;;;148    					S[i] = 0;					// 回到状态0
;;;149    				}
;;;150    			} else if (S[i] == 3) { 	//* 状态3: 双击确认状态
000090  2a03              CMP      r2,#3
000092  d02d              BEQ      |L4.240|
;;;151    				if (CurrState[i] == KEY_UNPRESSED) {
;;;152    					S[i] = 0;					// 回到状态0
;;;153    				}
;;;154    			} else if (S[i] == 4) {		//* 状态4: 长按状态
000094  2a04              CMP      r2,#4
000096  d02e              BEQ      |L4.246|
000098  e03e              B        |L4.280|
                  |L4.154|
00009a  2801              CMP      r0,#1                 ;129
00009c  d13c              BNE      |L4.280|
00009e  207d              MOVS     r0,#0x7d              ;130
0000a0  0100              LSLS     r0,r0,#4              ;130
0000a2  004a              LSLS     r2,r1,#1              ;130
0000a4  52a0              STRH     r0,[r4,r2]            ;130
0000a6  2001              MOVS     r0,#1                 ;131
0000a8  e035              B        |L4.278|
                  |L4.170|
0000aa  2800              CMP      r0,#0                 ;134
0000ac  d004              BEQ      |L4.184|
0000ae  0048              LSLS     r0,r1,#1              ;137
0000b0  5a22              LDRH     r2,[r4,r0]            ;137
0000b2  2a00              CMP      r2,#0                 ;137
0000b4  d005              BEQ      |L4.194|
0000b6  e02f              B        |L4.280|
                  |L4.184|
0000b8  20c8              MOVS     r0,#0xc8              ;135
0000ba  004a              LSLS     r2,r1,#1              ;135
0000bc  52a0              STRH     r0,[r4,r2]            ;135
0000be  2002              MOVS     r0,#2                 ;136
0000c0  e029              B        |L4.278|
                  |L4.194|
0000c2  2264              MOVS     r2,#0x64              ;138
0000c4  5222              STRH     r2,[r4,r0]            ;138
0000c6  5c68              LDRB     r0,[r5,r1]            ;139
0000c8  2220              MOVS     r2,#0x20              ;139
0000ca  e021              B        |L4.272|
                  |L4.204|
0000cc  2801              CMP      r0,#1                 ;143
0000ce  d004              BEQ      |L4.218|
0000d0  0048              LSLS     r0,r1,#1              ;146
0000d2  5a20              LDRH     r0,[r4,r0]            ;146
0000d4  2800              CMP      r0,#0                 ;146
0000d6  d006              BEQ      |L4.230|
0000d8  e01e              B        |L4.280|
                  |L4.218|
0000da  5c68              LDRB     r0,[r5,r1]            ;144
0000dc  2210              MOVS     r2,#0x10              ;144
0000de  4310              ORRS     r0,r0,r2              ;144
0000e0  5468              STRB     r0,[r5,r1]            ;144
0000e2  2003              MOVS     r0,#3                 ;145
0000e4  e017              B        |L4.278|
                  |L4.230|
0000e6  5c68              LDRB     r0,[r5,r1]            ;147
0000e8  2208              MOVS     r2,#8                 ;147
0000ea  4310              ORRS     r0,r0,r2              ;147
0000ec  5468              STRB     r0,[r5,r1]            ;147
0000ee  e009              B        |L4.260|
                  |L4.240|
0000f0  2800              CMP      r0,#0                 ;151
0000f2  d007              BEQ      |L4.260|
0000f4  e010              B        |L4.280|
                  |L4.246|
;;;155    				if (CurrState[i] == KEY_UNPRESSED) {
0000f6  2800              CMP      r0,#0
0000f8  d004              BEQ      |L4.260|
;;;156    					S[i] = 0;					// 回到状态0
;;;157    				} else if (Time[i] == 0) {		// 重复触发时间到
0000fa  0048              LSLS     r0,r1,#1
0000fc  5a22              LDRH     r2,[r4,r0]
0000fe  2a00              CMP      r2,#0
000100  d002              BEQ      |L4.264|
000102  e009              B        |L4.280|
                  |L4.260|
000104  545f              STRB     r7,[r3,r1]            ;156
000106  e007              B        |L4.280|
                  |L4.264|
;;;158    					Time[i] = KEY_TIME_REPEAT;	// 重新设置重复触发计时器
000108  2264              MOVS     r2,#0x64
00010a  5222              STRH     r2,[r4,r0]
;;;159    					Key_Flag[i] |= KEY_REPEAT;	// 置位重复触发标志
00010c  5c68              LDRB     r0,[r5,r1]
00010e  2240              MOVS     r2,#0x40
                  |L4.272|
000110  4310              ORRS     r0,r0,r2              ;139
000112  5468              STRB     r0,[r5,r1]            ;139
000114  2004              MOVS     r0,#4                 ;140
                  |L4.278|
;;;160    					S[i] = 4;					// 保持状态4
000116  5458              STRB     r0,[r3,r1]
                  |L4.280|
000118  1c49              ADDS     r1,r1,#1
00011a  b2c8              UXTB     r0,r1                 ;104
00011c  7070              STRB     r0,[r6,#1]            ;104
00011e  2805              CMP      r0,#5                 ;104
000120  d387              BCC      |L4.50|
                  |L4.290|
;;;161    				}
;;;162    			}
;;;163    		}
;;;164    	}
;;;165    }
000122  bdf8              POP      {r3-r7,pc}
                          ENDP

                  |L4.292|
                          DCD      ||.data||
                  |L4.296|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  Time
                          %        10

                          AREA ||.data||, DATA, ALIGN=0

                  Count
000000  00                DCB      0x00
                  i
000001  00                DCB      0x00
                  CurrState
000002  0000              DCB      0x00,0x00
000004  000000            DCB      0x00,0x00,0x00
                  PrevState
000007  00                DCB      0x00
                          DCDU     0x00000000
                  S
                          DCDU     0x00000000
000010  00                DCB      0x00
                  Key_Flag
000011  000000            DCB      0x00,0x00,0x00
000014  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\Apps\\Key.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_Key_c_Key_Init____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___5_Key_c_Key_Init____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_Key_c_Key_Init____REVSH|
#line 478
|__asm___5_Key_c_Key_Init____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
