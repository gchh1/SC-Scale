; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\led.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\led.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Algorithm -IC:\Users\gchh\AppData\Local\Arm\Packs\Keil\SC32F1xxx_DFP\1.1.7\Device\SC32F12xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=543 -DSC32f12xx -DSC32f12xx -DPrintfEable --omf_browse=..\output\led.crf ..\Apps\LED.c]
                          THUMB

                          AREA ||i.LEDX_Init||, CODE, READONLY, ALIGN=2

                  LEDX_Init PROC
;;;162    
;;;163    void LEDX_Init(void) {
000000  b51c              PUSH     {r2-r4,lr}
;;;164    	GPIO_InitTypeDef GPIO_InitStructure;
;;;165    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT_PP;
000002  2002              MOVS     r0,#2
000004  4669              MOV      r1,sp
000006  8048              STRH     r0,[r1,#2]
;;;166    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
000008  2039              MOVS     r0,#0x39
00000a  0280              LSLS     r0,r0,#10
00000c  8008              STRH     r0,[r1,#0]
;;;167    	GPIO_InitStructure.GPIO_DriveLevel = 0;
00000e  2000              MOVS     r0,#0
;;;168    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000010  4c0b              LDR      r4,|L1.64|
000012  8088              STRH     r0,[r1,#4]            ;167
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       GPIO_Init
;;;169    
;;;170    	GPIO_SetBits(GPIOB, GPIO_Pin_10); 
00001a  1521              ASRS     r1,r4,#20
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       GPIO_SetBits
;;;171    	GPIO_SetBits(GPIOB, GPIO_Pin_13); 
000022  1461              ASRS     r1,r4,#17
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       GPIO_SetBits
;;;172    	GPIO_SetBits(GPIOB, GPIO_Pin_14); 
00002a  2101              MOVS     r1,#1
00002c  0389              LSLS     r1,r1,#14
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_SetBits
;;;173    	GPIO_SetBits(GPIOB, GPIO_Pin_15); 
000034  2101              MOVS     r1,#1
000036  03c9              LSLS     r1,r1,#15
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       GPIO_SetBits
;;;174    }
00003e  bd1c              POP      {r2-r4,pc}
;;;175    
                          ENDP

                  |L1.64|
                          DCD      0x40011100

                          AREA ||i.LEDX_Off||, CODE, READONLY, ALIGN=2

                  LEDX_Off PROC
;;;186    
;;;187    void LEDX_Off(uint8_t LEDX) {
000000  b510              PUSH     {r4,lr}
;;;188    	if (LEDX < 2 || LEDX > 5) return;
000002  1e81              SUBS     r1,r0,#2
000004  2904              CMP      r1,#4
000006  d20d              BCS      |L2.36|
;;;189    	
;;;190    	switch(LEDX) {
;;;191    		case 2: GPIO_SetBits(GPIOB, GPIO_Pin_10); break;
000008  4a0b              LDR      r2,|L2.56|
00000a  2802              CMP      r0,#2                 ;190
00000c  d00b              BEQ      |L2.38|
00000e  2803              CMP      r0,#3                 ;190
000010  d00c              BEQ      |L2.44|
000012  2804              CMP      r0,#4                 ;190
000014  d00d              BEQ      |L2.50|
000016  2805              CMP      r0,#5                 ;190
000018  d104              BNE      |L2.36|
;;;192    		case 3: GPIO_SetBits(GPIOB, GPIO_Pin_13); break;
;;;193    		case 4: GPIO_SetBits(GPIOB, GPIO_Pin_14); break;
;;;194    		case 5: GPIO_SetBits(GPIOB, GPIO_Pin_15); break;
00001a  2101              MOVS     r1,#1
00001c  03c9              LSLS     r1,r1,#15
                  |L2.30|
00001e  4610              MOV      r0,r2
000020  f7fffffe          BL       GPIO_SetBits
                  |L2.36|
;;;195    	}
;;;196    }
000024  bd10              POP      {r4,pc}
                  |L2.38|
000026  2101              MOVS     r1,#1                 ;191
000028  0289              LSLS     r1,r1,#10             ;191
00002a  e7f8              B        |L2.30|
                  |L2.44|
00002c  2101              MOVS     r1,#1                 ;192
00002e  0349              LSLS     r1,r1,#13             ;192
000030  e7f5              B        |L2.30|
                  |L2.50|
000032  2101              MOVS     r1,#1                 ;193
000034  0389              LSLS     r1,r1,#14             ;193
000036  e7f2              B        |L2.30|
;;;197    
                          ENDP

                  |L2.56|
                          DCD      0x40011100

                          AREA ||i.LEDX_On||, CODE, READONLY, ALIGN=2

                  LEDX_On PROC
;;;175    
;;;176    void LEDX_On(uint8_t LEDX) {
000000  b510              PUSH     {r4,lr}
;;;177    	if (LEDX < 2 || LEDX > 5) return;
000002  1e81              SUBS     r1,r0,#2
000004  2904              CMP      r1,#4
000006  d20d              BCS      |L3.36|
;;;178    	
;;;179    	switch(LEDX) {
;;;180    		case 2: GPIO_ResetBits(GPIOB, GPIO_Pin_10); break;
000008  4a0b              LDR      r2,|L3.56|
00000a  2802              CMP      r0,#2                 ;179
00000c  d00b              BEQ      |L3.38|
00000e  2803              CMP      r0,#3                 ;179
000010  d00c              BEQ      |L3.44|
000012  2804              CMP      r0,#4                 ;179
000014  d00d              BEQ      |L3.50|
000016  2805              CMP      r0,#5                 ;179
000018  d104              BNE      |L3.36|
;;;181    		case 3: GPIO_ResetBits(GPIOB, GPIO_Pin_13); break;
;;;182    		case 4: GPIO_ResetBits(GPIOB, GPIO_Pin_14); break;
;;;183    		case 5: GPIO_ResetBits(GPIOB, GPIO_Pin_15); break;
00001a  2101              MOVS     r1,#1
00001c  03c9              LSLS     r1,r1,#15
                  |L3.30|
00001e  4610              MOV      r0,r2
000020  f7fffffe          BL       GPIO_ResetBits
                  |L3.36|
;;;184    	}
;;;185    }
000024  bd10              POP      {r4,pc}
                  |L3.38|
000026  2101              MOVS     r1,#1                 ;180
000028  0289              LSLS     r1,r1,#10             ;180
00002a  e7f8              B        |L3.30|
                  |L3.44|
00002c  2101              MOVS     r1,#1                 ;181
00002e  0349              LSLS     r1,r1,#13             ;181
000030  e7f5              B        |L3.30|
                  |L3.50|
000032  2101              MOVS     r1,#1                 ;182
000034  0389              LSLS     r1,r1,#14             ;182
000036  e7f2              B        |L3.30|
;;;186    
                          ENDP

                  |L3.56|
                          DCD      0x40011100

                          AREA ||i.LEDX_Shift||, CODE, READONLY, ALIGN=2

                  LEDX_Shift PROC
;;;197    
;;;198    void LEDX_Shift(uint8_t LEDX) {
000000  b570              PUSH     {r4-r6,lr}
;;;199    	if (LEDX < 2 || LEDX > 5) return;
000002  1e81              SUBS     r1,r0,#2
000004  2904              CMP      r1,#4
000006  d21e              BCS      |L4.70|
;;;200    	uint16_t pin;
;;;201    	
;;;202    	switch(LEDX) {
000008  2802              CMP      r0,#2
00000a  d006              BEQ      |L4.26|
00000c  2803              CMP      r0,#3
00000e  d007              BEQ      |L4.32|
000010  2804              CMP      r0,#4
000012  d008              BEQ      |L4.38|
000014  2805              CMP      r0,#5
000016  d10b              BNE      |L4.48|
000018  e008              B        |L4.44|
                  |L4.26|
;;;203    		case 2: pin = GPIO_Pin_10; break;
00001a  2401              MOVS     r4,#1
00001c  02a4              LSLS     r4,r4,#10
00001e  e007              B        |L4.48|
                  |L4.32|
;;;204    		case 3: pin = GPIO_Pin_13; break;
000020  2401              MOVS     r4,#1
000022  0364              LSLS     r4,r4,#13
000024  e004              B        |L4.48|
                  |L4.38|
;;;205    		case 4: pin = GPIO_Pin_14; break;
000026  2401              MOVS     r4,#1
000028  03a4              LSLS     r4,r4,#14
00002a  e001              B        |L4.48|
                  |L4.44|
;;;206    		case 5: pin = GPIO_Pin_15; break;
00002c  2401              MOVS     r4,#1
00002e  03e4              LSLS     r4,r4,#15
                  |L4.48|
;;;207    	}
;;;208    	
;;;209    	if (GPIO_ReadDataBit(GPIOB, pin) == RESET) {
000030  4d07              LDR      r5,|L4.80|
000032  4621              MOV      r1,r4
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       GPIO_ReadDataBit
00003a  2800              CMP      r0,#0
;;;210    		GPIO_SetBits(GPIOB, pin);
;;;211    	} else {
;;;212    		GPIO_ResetBits(GPIOB, pin);
00003c  4621              MOV      r1,r4
00003e  4628              MOV      r0,r5
000040  d002              BEQ      |L4.72|
000042  f7fffffe          BL       GPIO_ResetBits
                  |L4.70|
;;;213    	}
;;;214    }
000046  bd70              POP      {r4-r6,pc}
                  |L4.72|
000048  f7fffffe          BL       GPIO_SetBits
00004c  bd70              POP      {r4-r6,pc}
;;;215    
                          ENDP

00004e  0000              DCW      0x0000
                  |L4.80|
                          DCD      0x40011100

                          AREA ||i.LEDX_Shine||, CODE, READONLY, ALIGN=2

                  LEDX_Shine PROC
;;;228    
;;;229    void LEDX_Shine(uint8_t LEDX) {
000000  b570              PUSH     {r4-r6,lr}
;;;230     	uint16_t pin;
;;;231    	
;;;232    	switch(LEDX) {
000002  2802              CMP      r0,#2
000004  d006              BEQ      |L5.20|
000006  2803              CMP      r0,#3
000008  d007              BEQ      |L5.26|
00000a  2804              CMP      r0,#4
00000c  d008              BEQ      |L5.32|
00000e  2805              CMP      r0,#5
000010  d10b              BNE      |L5.42|
000012  e008              B        |L5.38|
                  |L5.20|
;;;233    		case 2: pin = GPIO_Pin_10; break;
000014  2401              MOVS     r4,#1
000016  02a4              LSLS     r4,r4,#10
000018  e007              B        |L5.42|
                  |L5.26|
;;;234    		case 3: pin = GPIO_Pin_13; break;
00001a  2401              MOVS     r4,#1
00001c  0364              LSLS     r4,r4,#13
00001e  e004              B        |L5.42|
                  |L5.32|
;;;235    		case 4: pin = GPIO_Pin_14; break;
000020  2401              MOVS     r4,#1
000022  03a4              LSLS     r4,r4,#14
000024  e001              B        |L5.42|
                  |L5.38|
;;;236    		case 5: pin = GPIO_Pin_15; break;
000026  2401              MOVS     r4,#1
000028  03e4              LSLS     r4,r4,#15
                  |L5.42|
;;;237    	}
;;;238    
;;;239        GPIO_ResetBits(GPIOB, pin);
00002a  4d06              LDR      r5,|L5.68|
00002c  4621              MOV      r1,r4
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       GPIO_ResetBits
;;;240        Delay_s(1);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       Delay_s
;;;241        GPIO_SetBits(GPIOB, pin);
00003a  4621              MOV      r1,r4
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       GPIO_SetBits
;;;242    }
000042  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L5.68|
                          DCD      0x40011100

                          AREA ||i.LEDX_State||, CODE, READONLY, ALIGN=2

                  LEDX_State PROC
;;;215    
;;;216    BitAction LEDX_State(uint8_t LEDX) {
000000  b510              PUSH     {r4,lr}
;;;217    	uint16_t pin;
;;;218    	
;;;219    	switch(LEDX) {
000002  2802              CMP      r0,#2
000004  d006              BEQ      |L6.20|
000006  2803              CMP      r0,#3
000008  d007              BEQ      |L6.26|
00000a  2804              CMP      r0,#4
00000c  d008              BEQ      |L6.32|
00000e  2805              CMP      r0,#5
000010  d10b              BNE      |L6.42|
000012  e008              B        |L6.38|
                  |L6.20|
;;;220    		case 2: pin = GPIO_Pin_10; break;
000014  2101              MOVS     r1,#1
000016  0289              LSLS     r1,r1,#10
000018  e007              B        |L6.42|
                  |L6.26|
;;;221    		case 3: pin = GPIO_Pin_13; break;
00001a  2101              MOVS     r1,#1
00001c  0349              LSLS     r1,r1,#13
00001e  e004              B        |L6.42|
                  |L6.32|
;;;222    		case 4: pin = GPIO_Pin_14; break;
000020  2101              MOVS     r1,#1
000022  0389              LSLS     r1,r1,#14
000024  e001              B        |L6.42|
                  |L6.38|
;;;223    		case 5: pin = GPIO_Pin_15; break;
000026  2101              MOVS     r1,#1
000028  03c9              LSLS     r1,r1,#15
                  |L6.42|
;;;224    	}
;;;225    	
;;;226    	return GPIO_ReadDataBit(GPIOB, pin);
00002a  4802              LDR      r0,|L6.52|
00002c  f7fffffe          BL       GPIO_ReadDataBit
;;;227    }
000030  bd10              POP      {r4,pc}
;;;228    
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      0x40011100

                          AREA ||i.LED_Clear||, CODE, READONLY, ALIGN=1

                  LED_Clear PROC
;;;42     
;;;43     void LED_Clear(void) {
000000  b510              PUSH     {r4,lr}
;;;44     	LED_Write(LED_RAMRegister_8, 0x00);
000002  2100              MOVS     r1,#0
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       LED_Write
;;;45     	LED_Write(LED_RAMRegister_9, 0x00);
00000a  2100              MOVS     r1,#0
00000c  2009              MOVS     r0,#9
00000e  f7fffffe          BL       LED_Write
;;;46     	LED_Write(LED_RAMRegister_10, 0x00);
000012  2100              MOVS     r1,#0
000014  200a              MOVS     r0,#0xa
000016  f7fffffe          BL       LED_Write
;;;47     	LED_Write(LED_RAMRegister_11, 0x00);
00001a  2100              MOVS     r1,#0
00001c  200b              MOVS     r0,#0xb
00001e  f7fffffe          BL       LED_Write
;;;48     	LED_Write(LED_RAMRegister_12, 0x00);
000022  2100              MOVS     r1,#0
000024  200c              MOVS     r0,#0xc
000026  f7fffffe          BL       LED_Write
;;;49     	LED_Write(LED_RAMRegister_13, 0x00);
00002a  2100              MOVS     r1,#0
00002c  200d              MOVS     r0,#0xd
00002e  f7fffffe          BL       LED_Write
;;;50     	LED_Write(LED_RAMRegister_14, 0x00);
000032  2100              MOVS     r1,#0
000034  200e              MOVS     r0,#0xe
000036  f7fffffe          BL       LED_Write
;;;51     	LED_Write(LED_RAMRegister_15, 0x00);
00003a  2100              MOVS     r1,#0
00003c  200f              MOVS     r0,#0xf
00003e  f7fffffe          BL       LED_Write
;;;52     }
000042  bd10              POP      {r4,pc}
;;;53     
                          ENDP


                          AREA ||i.LED_SetDot||, CODE, READONLY, ALIGN=1

                  LED_SetDot PROC
;;;92     
;;;93     void LED_SetDot(uint8_t position) {
000000  b510              PUSH     {r4,lr}
000002  1e40              SUBS     r0,r0,#1
;;;94     	// 1. 安全检查
;;;95     	if (position < 1 || position > 4) return;
000004  2804              CMP      r0,#4
000006  d206              BCS      |L8.22|
;;;96     	
;;;97     	LED_Write(LED_RAMRegister_13, (1 << (position - 1)) << 4);
000008  2101              MOVS     r1,#1
00000a  4081              LSLS     r1,r1,r0
00000c  0708              LSLS     r0,r1,#28
00000e  0e01              LSRS     r1,r0,#24
000010  200d              MOVS     r0,#0xd
000012  f7fffffe          BL       LED_Write
                  |L8.22|
;;;98     }
000016  bd10              POP      {r4,pc}
;;;99     
                          ENDP


                          AREA ||i.LED_SetNum||, CODE, READONLY, ALIGN=2

                  LED_SetNum PROC
;;;99     
;;;100    void LED_SetNum(uint16_t num) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4607              MOV      r7,r0
;;;101    	if (num > 9999) return;
000004  481f              LDR      r0,|L9.132|
000006  4287              CMP      r7,r0
000008  d835              BHI      |L9.118|
;;;102        
;;;103        // 1. 计算当前数字实际占用了哪些 COM 位 (从右往左)
;;;104        // 例如，如果 num=12，则使用了 COM7 和 COM6 (position 4 和 3)
;;;105        uint8_t current_num_length = 0;
00000a  2400              MOVS     r4,#0
;;;106        if (num == 0) { // 特殊处理 0
00000c  2f00              CMP      r7,#0
00000e  d00c              BEQ      |L9.42|
;;;107            current_num_length = 1; 
;;;108        } else {
;;;109            uint16_t temp_num = num;
000010  4638              MOV      r0,r7
                  |L9.18|
;;;110            while (temp_num > 0) {
;;;111                temp_num /= 10;
000012  210a              MOVS     r1,#0xa
000014  f7fffffe          BL       __aeabi_uidivmod
000018  1c64              ADDS     r4,r4,#1
;;;112                current_num_length++;
00001a  b2e4              UXTB     r4,r4
00001c  2800              CMP      r0,#0                 ;110
00001e  d1f8              BNE      |L9.18|
                  |L9.32|
;;;113            }
;;;114        }
;;;115        
;;;116        // 2. 清除未使用的 COM 位，以消除前一次显示的影响
;;;117        // 未使用的 COM 位从 position 1 开始，到 (4 - current_num_length) 结束
;;;118        // 例如，显示 "12" (长度为2)，则 position 1, 2 未使用 (COM4, COM5)
;;;119        for (int pos_to_clear = 1; pos_to_clear <= (4 - current_num_length); pos_to_clear++) {
000020  2501              MOVS     r5,#1
000022  2004              MOVS     r0,#4
000024  1b00              SUBS     r0,r0,r4
000026  9000              STR      r0,[sp,#0]
000028  e015              B        |L9.86|
                  |L9.42|
00002a  2401              MOVS     r4,#1                 ;107
00002c  e7f8              B        |L9.32|
                  |L9.46|
;;;120            uint8_t com_mask = 1 << ((pos_to_clear - 1) + 4);
00002e  1ce8              ADDS     r0,r5,#3
000030  2101              MOVS     r1,#1
000032  4081              LSLS     r1,r1,r0
000034  b2ce              UXTB     r6,r1
;;;121            // 遍历所有 SEG 寄存器 (假设有 15 个，即 0-14 偏移量)
;;;122            // 假设 Segment_Map 的最大偏移量在 [0, 14] 之间
;;;123            // 这里需要知道 LED_RAM_Buffer 的实际大小或有效索引范围
;;;124            // 根据您的代码，LED_RAM_Buffer 只使用了 Segment_Map 索引的偏移量
;;;125            
;;;126            // 我们可以遍历所有段的偏移量 (0-7 对应 a-dp)
;;;127            for (int i = 0; i < 8; i++) {
000036  2400              MOVS     r4,#0
                  |L9.56|
;;;128                uint8_t reg_offset = Segment_Map[i];
000038  4813              LDR      r0,|L9.136|
;;;129                
;;;130                // 清除缓存中对应 COM 位
;;;131                LED_RAM_Buffer[reg_offset] &= ~com_mask;
00003a  4a14              LDR      r2,|L9.140|
00003c  5d00              LDRB     r0,[r0,r4]            ;128
00003e  5c11              LDRB     r1,[r2,r0]
000040  43b1              BICS     r1,r1,r6
000042  5411              STRB     r1,[r2,r0]
000044  3008              ADDS     r0,r0,#8
;;;132                
;;;133                // 写入硬件
;;;134                LED_Write(LED_RAMRegister_8 + reg_offset, LED_RAM_Buffer[reg_offset]);
000046  b2c0              UXTB     r0,r0
000048  f7fffffe          BL       LED_Write
00004c  1c64              ADDS     r4,r4,#1
00004e  2c08              CMP      r4,#8                 ;127
000050  dbf2              BLT      |L9.56|
000052  9800              LDR      r0,[sp,#0]            ;127
000054  1c6d              ADDS     r5,r5,#1              ;127
                  |L9.86|
000056  42a8              CMP      r0,r5                 ;119
000058  dae9              BGE      |L9.46|
;;;135            }
;;;136            
;;;137            // 额外处理 DP 段，它通常位于不同的寄存器 (LED_RAMRegister_13)
;;;138            // 假设 DP 段也受 COM 位的控制，并且 position i 的 DP 对应 (1 << (i - 1)) << 4
;;;139            // 您需要知道 DP 寄存器在 LED_RAM_Buffer 中的索引 (如果它也在 buffer 中)
;;;140            // 如果 DP 不在 LED_RAM_Buffer 中，则需要单独处理 DP 寄存器的清除
;;;141            // 鉴于您 LED_SetDot 只写 LED_RAMRegister_13，我们假设它不在此清除循环内，
;;;142            // 并且 LED_SetDot 的设计是覆盖式写入，所以这里可能不需要处理 DP。
;;;143        }
;;;144    
;;;145        // 3. 设置当前数字
;;;146        int po = 4; // 从最右边一位开始
00005a  2404              MOVS     r4,#4
;;;147        uint16_t temp_num = num;
00005c  0038              MOVS     r0,r7
;;;148        
;;;149        // 如果数字为 0，也需要显示
;;;150        if (temp_num == 0) {
00005e  d00b              BEQ      |L9.120|
                  |L9.96|
;;;151            LED_SetOneDigit(po, 0);
;;;152            return; // 显示完毕
;;;153        }
;;;154    
;;;155        while (temp_num > 0) {
;;;156            LED_SetOneDigit(po, temp_num % 10);
000060  210a              MOVS     r1,#0xa
000062  f7fffffe          BL       __aeabi_uidivmod
000066  4605              MOV      r5,r0
000068  b2e0              UXTB     r0,r4
00006a  f7fffffe          BL       LED_SetOneDigit
00006e  1e64              SUBS     r4,r4,#1
000070  4628              MOV      r0,r5
000072  2d00              CMP      r5,#0                 ;155
;;;157            temp_num /= 10;
;;;158            po --;
000074  d1f4              BNE      |L9.96|
                  |L9.118|
;;;159        }
;;;160    }
000076  bdf8              POP      {r3-r7,pc}
                  |L9.120|
000078  2004              MOVS     r0,#4                 ;151
00007a  2100              MOVS     r1,#0                 ;151
00007c  f7fffffe          BL       LED_SetOneDigit
000080  bdf8              POP      {r3-r7,pc}
;;;161    	
                          ENDP

000082  0000              DCW      0x0000
                  |L9.132|
                          DCD      0x0000270f
                  |L9.136|
                          DCD      ||.constdata||
                  |L9.140|
                          DCD      ||.data||

                          AREA ||i.LED_SetOneDigit||, CODE, READONLY, ALIGN=2

                  LED_SetOneDigit PROC
;;;58      */
;;;59     void LED_SetOneDigit(uint8_t position, uint8_t number) {
000000  b5f8              PUSH     {r3-r7,lr}
;;;60         // 1. 安全检查
;;;61         if (position < 1 || position > 4) return;
000002  1e42              SUBS     r2,r0,#1
000004  2a04              CMP      r2,#4
000006  d21d              BCS      |L10.68|
;;;62         if (number > 9) return;
000008  2909              CMP      r1,#9
00000a  d81b              BHI      |L10.68|
;;;63     
;;;64         // 2. 获取标准段码 (比如数字 '1' 是 0x06)
;;;65         uint8_t seg_code = LED_Digit_Code[number]; 
00000c  4a0e              LDR      r2,|L10.72|
;;;66         
;;;67         // 3. 计算位掩码 (High Nibble Logic)
;;;68         // COM4(Pos1) -> bit4 (0x10)
;;;69         // COM5(Pos2) -> bit5 (0x20) ...
;;;70         uint8_t com_mask = 1 << ((position - 1) + 4); 
00000e  1cc0              ADDS     r0,r0,#3
000010  5c57              LDRB     r7,[r2,r1]            ;65
000012  2101              MOVS     r1,#1
000014  4081              LSLS     r1,r1,r0
;;;71     
;;;72         // 4. 遍历标准段 a-dp (共8个)
;;;73         for (int i = 0; i < 8; i++) {
;;;74             // 查找当前段对应的硬件 SEG 寄存器偏移量
;;;75             uint8_t reg_offset = Segment_Map[i];
;;;76             
;;;77             // 检查数字的这一段是否需要亮
;;;78             if ((seg_code >> i) & 0x01) {
;;;79                 // 需要亮 -> 设置缓存中对应的 COM 位
;;;80                 LED_RAM_Buffer[reg_offset] |= com_mask;
000016  4e0d              LDR      r6,|L10.76|
000018  b2cd              UXTB     r5,r1                 ;70
00001a  2400              MOVS     r4,#0                 ;73
                  |L10.28|
00001c  480a              LDR      r0,|L10.72|
00001e  4639              MOV      r1,r7                 ;75
000020  3808              SUBS     r0,r0,#8              ;75
000022  5d00              LDRB     r0,[r0,r4]            ;75
000024  40e1              LSRS     r1,r1,r4              ;78
000026  07c9              LSLS     r1,r1,#31             ;78
;;;81             }
;;;82             else {
;;;83                 // 需要灭 -> 清除缓存中对应的 COM 位
;;;84                 LED_RAM_Buffer[reg_offset] &= ~com_mask;
000028  5c31              LDRB     r1,[r6,r0]
00002a  d001              BEQ      |L10.48|
00002c  4329              ORRS     r1,r1,r5              ;80
00002e  e000              B        |L10.50|
                  |L10.48|
000030  43a9              BICS     r1,r1,r5
                  |L10.50|
000032  5431              STRB     r1,[r6,r0]
;;;85             }
;;;86     
;;;87             // 5. 将更新后的数据写入硬件
;;;88             // 基础地址 LED_RAMRegister_8 + 偏移量
;;;89             LED_Write(LED_RAMRegister_8 + reg_offset, LED_RAM_Buffer[reg_offset]);
000034  3008              ADDS     r0,r0,#8
000036  b2c9              UXTB     r1,r1
000038  b2c0              UXTB     r0,r0
00003a  f7fffffe          BL       LED_Write
00003e  1c64              ADDS     r4,r4,#1
000040  2c08              CMP      r4,#8                 ;73
000042  dbeb              BLT      |L10.28|
                  |L10.68|
;;;90         }
;;;91     }
000044  bdf8              POP      {r3-r7,pc}
;;;92     
                          ENDP

000046  0000              DCW      0x0000
                  |L10.72|
                          DCD      ||.constdata||+0x8
                  |L10.76|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Segment_Map
000000  00020406          DCB      0x00,0x02,0x04,0x06
000004  07010305          DCB      0x07,0x01,0x03,0x05
                  LED_Digit_Code
000008  3f065b4f          DCB      0x3f,0x06,0x5b,0x4f
00000c  666d7d07          DCB      0x66,0x6d,0x7d,0x07
000010  7f6f              DCB      0x7f,0x6f

                          AREA ||.data||, DATA, ALIGN=0

                  LED_RAM_Buffer
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCDU     0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Apps\\LED.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_LED_c_bd74ff08____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___5_LED_c_bd74ff08____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_LED_c_bd74ff08____REVSH|
#line 478
|__asm___5_LED_c_bd74ff08____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
