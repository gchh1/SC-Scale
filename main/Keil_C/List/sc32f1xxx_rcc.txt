; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_rcc.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_rcc.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Algorithm -IC:\Users\gchh\AppData\Local\Arm\Packs\Keil\SC32F1xxx_DFP\1.1.7\Device\SC32F12xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=543 -DSC32f12xx -DSC32f12xx -DPrintfEable --omf_browse=..\output\sc32f1xxx_rcc.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_rcc.c]
                          THUMB

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;763      */
;;;764    void RCC_AHBPeriphClockCmd ( uint32_t RCC_AHBPeriph, FunctionalState NewState )
000000  4a04              LDR      r2,|L1.20|
;;;765    {
;;;766        /* Check the parameters */
;;;767        assert_param ( IS_RCC_AHBPERIPH ( RCC_AHBPeriph ) );
;;;768    
;;;769        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;770        {
;;;771            RCCAHB->AHB_CFG |= RCC_AHBPeriph;
;;;772        }
;;;773        else
;;;774        {
;;;775            RCCAHB->AHB_CFG &= ~RCC_AHBPeriph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L1.12|
000008  4301              ORRS     r1,r1,r0              ;771
00000a  e000              B        |L1.14|
                  |L1.12|
00000c  4381              BICS     r1,r1,r0
                  |L1.14|
00000e  6011              STR      r1,[r2,#0]            ;771
;;;776        }
;;;777    }
000010  4770              BX       lr
;;;778    
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40003000

                          AREA ||i.RCC_AHBPeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphResetCmd PROC
;;;900     */
;;;901    void RCC_AHBPeriphResetCmd ( uint32_t RCC_AHBPeriph, FunctionalState NewState )
000000  4a04              LDR      r2,|L2.20|
;;;902    {
;;;903        /* Check the parameters */
;;;904        assert_param ( IS_RCC_AHBPERIPH ( RCC_AHBPeriph ) );
;;;905    
;;;906        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;907        {
;;;908            RCCAHB->AHB_RST |= RCC_AHBPeriph;
;;;909        }
;;;910        else
;;;911        {
;;;912            RCCAHB->AHB_RST &= ~RCC_AHBPeriph;
000004  6851              LDR      r1,[r2,#4]
000006  d001              BEQ      |L2.12|
000008  4301              ORRS     r1,r1,r0              ;908
00000a  e000              B        |L2.14|
                  |L2.12|
00000c  4381              BICS     r1,r1,r0
                  |L2.14|
00000e  6051              STR      r1,[r2,#4]            ;908
;;;913        }
;;;914    }
000010  4770              BX       lr
;;;915    
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40003000

                          AREA ||i.RCC_APB0Cmd||, CODE, READONLY, ALIGN=2

                  RCC_APB0Cmd PROC
;;;274      */
;;;275    void RCC_APB0Cmd ( FunctionalState NewState )
000000  4904              LDR      r1,|L3.20|
;;;276    {
;;;277        /* Check the parameters */
;;;278        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;279    
;;;280        if ( NewState != DISABLE )
;;;281        {
;;;282            RCCAPB0->APB0_CFG |= APB0_CFG_ENAPB;
000002  018a              LSLS     r2,r1,#6
000004  2800              CMP      r0,#0                 ;280
;;;283        }
;;;284        else
;;;285        {
;;;286            RCCAPB0->APB0_CFG &= ~APB0_CFG_ENAPB;
000006  6808              LDR      r0,[r1,#0]
000008  d001              BEQ      |L3.14|
00000a  4310              ORRS     r0,r0,r2              ;282
00000c  e000              B        |L3.16|
                  |L3.14|
00000e  4390              BICS     r0,r0,r2
                  |L3.16|
000010  6008              STR      r0,[r1,#0]            ;282
;;;287        }
;;;288    }
000012  4770              BX       lr
;;;289    
                          ENDP

                  |L3.20|
                          DCD      0x40020000

                          AREA ||i.RCC_APB0Config||, CODE, READONLY, ALIGN=2

                  RCC_APB0Config PROC
;;;533     */
;;;534    void RCC_APB0Config ( RCC_PCLK_TypeDef RCC_APB0CLK )
000000  4904              LDR      r1,|L4.20|
;;;535    {
;;;536        /* Check the parameters */
;;;537        assert_param ( IS_RCC_PCLK ( RCC_APB0CLK ) );
;;;538    
;;;539        RCCAPB0->APB0_CFG &= ~ ( ( uint32_t ) APB0_CFG_CLKDIV );
000002  680a              LDR      r2,[r1,#0]
000004  2307              MOVS     r3,#7
000006  051b              LSLS     r3,r3,#20
000008  439a              BICS     r2,r2,r3
00000a  600a              STR      r2,[r1,#0]
;;;540        RCCAPB0->APB0_CFG |= RCC_APB0CLK;
00000c  680a              LDR      r2,[r1,#0]
00000e  4302              ORRS     r2,r2,r0
000010  600a              STR      r2,[r1,#0]
;;;541    }
000012  4770              BX       lr
;;;542    
                          ENDP

                  |L4.20|
                          DCD      0x40020000

                          AREA ||i.RCC_APB0PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB0PeriphClockCmd PROC
;;;801      */
;;;802    void RCC_APB0PeriphClockCmd ( uint32_t RCC_APB0Periph, FunctionalState NewState )
000000  4a04              LDR      r2,|L5.20|
;;;803    {
;;;804        /* Check the parameters */
;;;805        assert_param ( IS_RCC_APB0PERIPH ( RCC_APB0Periph ) );
;;;806    
;;;807        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;808        {
;;;809            RCCAPB0->APB0_CFG |= RCC_APB0Periph;
;;;810        }
;;;811        else
;;;812        {
;;;813            RCCAPB0->APB0_CFG &= ~RCC_APB0Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L5.12|
000008  4301              ORRS     r1,r1,r0              ;809
00000a  e000              B        |L5.14|
                  |L5.12|
00000c  4381              BICS     r1,r1,r0
                  |L5.14|
00000e  6011              STR      r1,[r2,#0]            ;809
;;;814        }
;;;815    }
000010  4770              BX       lr
;;;816    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40020000

                          AREA ||i.RCC_APB0PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB0PeriphResetCmd PROC
;;;938     */
;;;939    void RCC_APB0PeriphResetCmd ( uint32_t RCC_APB0Periph, FunctionalState NewState )
000000  4a04              LDR      r2,|L6.20|
;;;940    {
;;;941        /* Check the parameters */
;;;942        assert_param ( IS_RCC_APB0PERIPH ( RCC_APB0Periph ) );
;;;943    
;;;944        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;945        {
;;;946            RCCAPB0->APB0_RST |= RCC_APB0Periph;
;;;947        }
;;;948        else
;;;949        {
;;;950            RCCAPB0->APB0_RST &= ~RCC_APB0Periph;
000004  6851              LDR      r1,[r2,#4]
000006  d001              BEQ      |L6.12|
000008  4301              ORRS     r1,r1,r0              ;946
00000a  e000              B        |L6.14|
                  |L6.12|
00000c  4381              BICS     r1,r1,r0
                  |L6.14|
00000e  6051              STR      r1,[r2,#4]            ;946
;;;951        }
;;;952    }
000010  4770              BX       lr
;;;953    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40020000

                          AREA ||i.RCC_APB1Cmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1Cmd PROC
;;;296      */
;;;297    void RCC_APB1Cmd ( FunctionalState NewState )
000000  2201              MOVS     r2,#1
;;;298    {
;;;299        /* Check the parameters */
;;;300        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;301    
;;;302        if ( NewState != DISABLE )
;;;303        {
;;;304            RCCAPB1->APB1_CFG |= APB1_CFG_ENAPB;
000002  4905              LDR      r1,|L7.24|
000004  05d2              LSLS     r2,r2,#23
000006  2800              CMP      r0,#0                 ;302
;;;305        }
;;;306        else
;;;307        {
;;;308            RCCAPB1->APB1_CFG &= ~APB1_CFG_ENAPB;
000008  6808              LDR      r0,[r1,#0]
00000a  d001              BEQ      |L7.16|
00000c  4310              ORRS     r0,r0,r2              ;304
00000e  e000              B        |L7.18|
                  |L7.16|
000010  4390              BICS     r0,r0,r2
                  |L7.18|
000012  6008              STR      r0,[r1,#0]            ;304
;;;309        }
;;;310    }
000014  4770              BX       lr
;;;311    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1Config||, CODE, READONLY, ALIGN=2

                  RCC_APB1Config PROC
;;;555     */
;;;556    void RCC_APB1Config ( RCC_PCLK_TypeDef RCC_APB1CLK )
000000  4904              LDR      r1,|L8.20|
;;;557    {
;;;558        /* Check the parameters */
;;;559        assert_param ( IS_RCC_PCLK ( RCC_APB1CLK ) );
;;;560    
;;;561        RCCAPB1->APB1_CFG &= ~ ( ( uint32_t ) APB1_CFG_CLKDIV );
000002  680a              LDR      r2,[r1,#0]
000004  2307              MOVS     r3,#7
000006  051b              LSLS     r3,r3,#20
000008  439a              BICS     r2,r2,r3
00000a  600a              STR      r2,[r1,#0]
;;;562        RCCAPB1->APB1_CFG |= RCC_APB1CLK;
00000c  680a              LDR      r2,[r1,#0]
00000e  4302              ORRS     r2,r2,r0
000010  600a              STR      r2,[r1,#0]
;;;563    }
000012  4770              BX       lr
;;;564    
                          ENDP

                  |L8.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;838      */
;;;839    void RCC_APB1PeriphClockCmd ( uint32_t RCC_APB1Periph, FunctionalState NewState )
000000  4a04              LDR      r2,|L9.20|
;;;840    {
;;;841        /* Check the parameters */
;;;842        assert_param ( IS_RCC_APB1PERIPH ( RCC_APB1Periph ) );
;;;843    
;;;844        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;845        {
;;;846            RCCAPB1->APB1_CFG |= RCC_APB1Periph;
;;;847        }
;;;848        else
;;;849        {
;;;850            RCCAPB1->APB1_CFG &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L9.12|
000008  4301              ORRS     r1,r1,r0              ;846
00000a  e000              B        |L9.14|
                  |L9.12|
00000c  4381              BICS     r1,r1,r0
                  |L9.14|
00000e  6011              STR      r1,[r2,#0]            ;846
;;;851        }
;;;852    }
000010  4770              BX       lr
;;;853    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;975     */
;;;976    void RCC_APB1PeriphResetCmd ( uint32_t RCC_APB1Periph, FunctionalState NewState )
000000  4a04              LDR      r2,|L10.20|
;;;977    {
;;;978        /* Check the parameters */
;;;979        assert_param ( IS_RCC_APB1PERIPH ( RCC_APB1Periph ) );
;;;980    
;;;981        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;982        {
;;;983            RCCAPB1->APB1_RST |= RCC_APB1Periph;
;;;984        }
;;;985        else
;;;986        {
;;;987            RCCAPB1->APB1_RST &= ~RCC_APB1Periph;
000004  6851              LDR      r1,[r2,#4]
000006  d001              BEQ      |L10.12|
000008  4301              ORRS     r1,r1,r0              ;983
00000a  e000              B        |L10.14|
                  |L10.12|
00000c  4381              BICS     r1,r1,r0
                  |L10.14|
00000e  6051              STR      r1,[r2,#4]            ;983
;;;988        }
;;;989    }
000010  4770              BX       lr
;;;990    
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2Cmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2Cmd PROC
;;;318      */
;;;319    void RCC_APB2Cmd ( FunctionalState NewState )
000000  2201              MOVS     r2,#1
;;;320    {
;;;321        /* Check the parameters */
;;;322        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;323    
;;;324        if ( NewState != DISABLE )
;;;325        {
;;;326            RCCAPB2->APB2_CFG |= APB2_CFG_ENAPB;
000002  4905              LDR      r1,|L11.24|
000004  05d2              LSLS     r2,r2,#23
000006  2800              CMP      r0,#0                 ;324
;;;327        }
;;;328        else
;;;329        {
;;;330            RCCAPB2->APB2_CFG &= ~APB2_CFG_ENAPB;
000008  6808              LDR      r0,[r1,#0]
00000a  d001              BEQ      |L11.16|
00000c  4310              ORRS     r0,r0,r2              ;326
00000e  e000              B        |L11.18|
                  |L11.16|
000010  4390              BICS     r0,r0,r2
                  |L11.18|
000012  6008              STR      r0,[r1,#0]            ;326
;;;331        }
;;;332    }
000014  4770              BX       lr
;;;333    
                          ENDP

000016  0000              DCW      0x0000
                  |L11.24|
                          DCD      0x40022000

                          AREA ||i.RCC_APB2Config||, CODE, READONLY, ALIGN=2

                  RCC_APB2Config PROC
;;;577     */
;;;578    void RCC_APB2Config ( RCC_PCLK_TypeDef RCC_APB2CLK )
000000  4904              LDR      r1,|L12.20|
;;;579    {
;;;580        /* Check the parameters */
;;;581        assert_param ( IS_RCC_PCLK ( RCC_APB2CLK ) );
;;;582    
;;;583        RCCAPB2->APB2_CFG &= ~ ( ( uint32_t ) APB2_CFG_CLKDIV );
000002  680a              LDR      r2,[r1,#0]
000004  2307              MOVS     r3,#7
000006  051b              LSLS     r3,r3,#20
000008  439a              BICS     r2,r2,r3
00000a  600a              STR      r2,[r1,#0]
;;;584        RCCAPB2->APB2_CFG |= RCC_APB2CLK;
00000c  680a              LDR      r2,[r1,#0]
00000e  4302              ORRS     r2,r2,r0
000010  600a              STR      r2,[r1,#0]
;;;585    }
000012  4770              BX       lr
;;;586    
                          ENDP

                  |L12.20|
                          DCD      0x40022000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;870      */
;;;871    void RCC_APB2PeriphClockCmd ( uint32_t RCC_APB2Periph, FunctionalState NewState )
000000  4a04              LDR      r2,|L13.20|
;;;872    {
;;;873        /* Check the parameters */
;;;874        assert_param ( IS_RCC_APB2PERIPH ( RCC_APB2Periph ) );
;;;875    
;;;876        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;877        {
;;;878            RCCAPB2->APB2_CFG |= RCC_APB2Periph;
;;;879        }
;;;880        else
;;;881        {
;;;882            RCCAPB2->APB2_CFG &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L13.12|
000008  4301              ORRS     r1,r1,r0              ;878
00000a  e000              B        |L13.14|
                  |L13.12|
00000c  4381              BICS     r1,r1,r0
                  |L13.14|
00000e  6011              STR      r1,[r2,#0]            ;878
;;;883        }
;;;884    }
000010  4770              BX       lr
;;;885    
                          ENDP

000012  0000              DCW      0x0000
                  |L13.20|
                          DCD      0x40022000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1007    */
;;;1008   void RCC_APB2PeriphResetCmd ( uint32_t RCC_APB2Periph, FunctionalState NewState )
000000  4a04              LDR      r2,|L14.20|
;;;1009   {
;;;1010       /* Check the parameters */
;;;1011       assert_param ( IS_RCC_APB2PERIPH ( RCC_APB2Periph ) );
;;;1012   
;;;1013       if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;1014       {
;;;1015           RCCAPB2->APB2_RST |= RCC_APB2Periph;
;;;1016       }
;;;1017       else
;;;1018       {
;;;1019           RCCAPB2->APB2_RST &= ~RCC_APB2Periph;
000004  6851              LDR      r1,[r2,#4]
000006  d001              BEQ      |L14.12|
000008  4301              ORRS     r1,r1,r0              ;1015
00000a  e000              B        |L14.14|
                  |L14.12|
00000c  4381              BICS     r1,r1,r0
                  |L14.14|
00000e  6051              STR      r1,[r2,#4]            ;1015
;;;1020       }
;;;1021   }
000010  4770              BX       lr
;;;1022   
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40022000

                          AREA ||i.RCC_BTMCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_BTMCLKConfig PROC
;;;737     */
;;;738    void RCC_BTMCLKConfig ( RCC_BTMCLKSource_TypeDef RCC_BTMCLKSource )
000000  b500              PUSH     {lr}
;;;739    {
000002  4602              MOV      r2,r0
;;;740        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;741        /* Check the parameters */
;;;742        assert_param ( RCC_BTMCLKSOURCE ( RCC_BTMCLKSource ) );
;;;743    
;;;744        RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_BTMCLKSEL );
00000a  4904              LDR      r1,|L15.28|
00000c  6988              LDR      r0,[r1,#0x18]
00000e  0840              LSRS     r0,r0,#1
000010  0040              LSLS     r0,r0,#1
000012  6188              STR      r0,[r1,#0x18]
;;;745        RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_BTMCLKSource );
000014  698b              LDR      r3,[r1,#0x18]
000016  4313              ORRS     r3,r3,r2
000018  618b              STR      r3,[r1,#0x18]
;;;746    }
00001a  bd00              POP      {pc}
;;;747    
                          ENDP

                  |L15.28|
                          DCD      0x40003000

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1221    */
;;;1222   void RCC_ClearFlag ( uint32_t RCC_FLAG )
000000  4902              LDR      r1,|L16.12|
;;;1223   {
;;;1224       /* Check the parameters */
;;;1225       assert_param ( IS_GET_RCC_FLAG ( RCC_FLAG ) );
;;;1226   
;;;1227       /* Clear the flags */
;;;1228       RCC->RCC_STS |= ( uint32_t ) RCC_FLAG;
000002  6a0a              LDR      r2,[r1,#0x20]
000004  4302              ORRS     r2,r2,r0
000006  620a              STR      r2,[r1,#0x20]
;;;1229   }
000008  4770              BX       lr
;;;1230   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40003000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;62      */
;;;63     void RCC_DeInit ( void )
000000  4804              LDR      r0,|L17.20|
;;;64     {
;;;65         /*	RCC Reg Unlock = 0 */
;;;66         RCC->RCC_KEY = 0x40;
000002  2140              MOVS     r1,#0x40
000004  60c1              STR      r1,[r0,#0xc]
;;;67     
;;;68         /* Reset RCC_CFG0 register */
;;;69         RCC->RCC_CFG0 = ( uint32_t ) 0x00001040;
000006  2141              MOVS     r1,#0x41
000008  0189              LSLS     r1,r1,#6
00000a  6141              STR      r1,[r0,#0x14]
;;;70     
;;;71         /* Reset RCC_CFG1 register */
;;;72         RCC->RCC_CFG1 = ( uint32_t ) 0x00000000;
00000c  2100              MOVS     r1,#0
00000e  6181              STR      r1,[r0,#0x18]
;;;73     
;;;74     #if defined(SC32f10xx)
;;;75         /* Reset PLL_CFG register */
;;;76         RCC->PLL_CFG = ( uint32_t ) 0x00000000;
;;;77     #endif
;;;78     
;;;79         /* Reset PLL_CFG register */
;;;80         RCC->NMI_CFG = ( uint32_t ) 0x00000000;
000010  62c1              STR      r1,[r0,#0x2c]
;;;81     
;;;82     }
000012  4770              BX       lr
;;;83     
                          ENDP

                  |L17.20|
                          DCD      0x40003000

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;592      */
;;;593    void RCC_GetClocksFreq ( RCC_ClocksTypeDef* RCC_Clocks )
000000  4a1c              LDR      r2,|L18.116|
;;;594    {
;;;595        uint32_t  tmp;
;;;596    
;;;597    #if defined(SC32f10xx)
;;;598        uint32_t  pllp, pllsource, pllm, plln;
;;;599    #endif
;;;600    
;;;601        /* Get SYSCLK source -------------------------------------------------------*/
;;;602        if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) == RESET )
000002  6951              LDR      r1,[r2,#0x14]
000004  0609              LSLS     r1,r1,#24
000006  d401              BMI      |L18.12|
;;;603        {
;;;604    #if defined(SC32f10xx) || defined(SC32f12xx)
;;;605           RCC_Clocks->SYSCLK_Frequency = HIRC_VALUE / 2;      
000008  491b              LDR      r1,|L18.120|
00000a  e017              B        |L18.60|
                  |L18.12|
;;;606    #endif
;;;607        }
;;;608        else
;;;609        {
;;;610            switch ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSEL )
00000c  6951              LDR      r1,[r2,#0x14]
00000e  2303              MOVS     r3,#3
000010  021b              LSLS     r3,r3,#8
000012  4019              ANDS     r1,r1,r3
000014  d00b              BEQ      |L18.46|
000016  39ff              SUBS     r1,r1,#0xff
000018  1e49              SUBS     r1,r1,#1
00001a  d006              BEQ      |L18.42|
00001c  39ff              SUBS     r1,r1,#0xff
00001e  1e49              SUBS     r1,r1,#1
000020  d00b              BEQ      |L18.58|
000022  39ff              SUBS     r1,r1,#0xff
000024  2901              CMP      r1,#1
000026  d10a              BNE      |L18.62|
000028  e004              B        |L18.52|
                  |L18.42|
;;;611            {
;;;612    #if defined(SC32f12xx)
;;;613            case RCC_SYSCLKSource_HXT:   /* HXT used as system clock source */
;;;614                RCC_Clocks->SYSCLK_Frequency = HXT_VALUE;
00002a  4914              LDR      r1,|L18.124|
;;;615                break;
00002c  e006              B        |L18.60|
                  |L18.46|
;;;616    #endif
;;;617            case RCC_SYSCLKSource_LIRC:   /* LIRC used as system clock source */
;;;618                RCC_Clocks->SYSCLK_Frequency = LIRC_VALUE;
00002e  217d              MOVS     r1,#0x7d
000030  0209              LSLS     r1,r1,#8
;;;619                break;
000032  e003              B        |L18.60|
                  |L18.52|
;;;620            case RCC_SYSCLKSource_LXT:   /* LXT used as system clock source */
;;;621                RCC_Clocks->SYSCLK_Frequency = LXT_VALUE;
000034  2101              MOVS     r1,#1
000036  03c9              LSLS     r1,r1,#15
;;;622                break;
000038  e000              B        |L18.60|
                  |L18.58|
;;;623    #if defined(SC32f12xx)
;;;624            case RCC_SYSCLKSource_HIRC:   /* HIRC used as system clock source */
;;;625                RCC_Clocks->SYSCLK_Frequency = HIRC_VALUE;
00003a  4911              LDR      r1,|L18.128|
                  |L18.60|
00003c  6001              STR      r1,[r0,#0]
                  |L18.62|
;;;626                break;
;;;627    #elif defined(SC32f10xx)
;;;628            case RCC_SYSCLKSource_PLLRCLK:   /* PLL used as system clock source */
;;;629                if ( ( RCC->PLL_CFG & PLL_CFG_PLLCLKSEL ) == RESET ) /* HXT used as PLL clock source */
;;;630                {
;;;631                    pllsource = HIRC_VALUE;
;;;632                }
;;;633                else   /* HIRC used as PLL clock source */
;;;634                {
;;;635                    pllsource = HXT_VALUE;
;;;636                }
;;;637    
;;;638                pllm = ( ( RCC->PLL_CFG & PLL_CFG_MDIVM ) >> PLL_CFG_MDIVM_Pos );
;;;639                plln = ( ( RCC->PLL_CFG & PLL_CFG_NDIVN ) >> PLL_CFG_NDIVN_Pos );
;;;640                pllp = ( ( RCC->PLL_CFG & PLL_CFG_PDIVP ) >> PLL_CFG_PDIVP_Pos );
;;;641    
;;;642                RCC_Clocks->SYSCLK_Frequency = ( ( ( pllsource / pllm ) * plln ) >> ( pllp + 1 ) );
;;;643                break;
;;;644    #endif
;;;645            }
;;;646        }
;;;647    
;;;648        /* Get AHB source -------------------------------------------------------*/
;;;649        tmp = ( ( RCCAHB->AHB_CFG & AHB_CFG_CLKDIV ) >> AHB_CFG_CLKDIV_Pos );
00003e  6811              LDR      r1,[r2,#0]
;;;650        RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> tmp;
;;;651    
;;;652        /* Get APB source -------------------------------------------------------*/
;;;653        tmp = ( ( RCCAPB0->APB0_CFG & APB0_CFG_CLKDIV ) >> APB0_CFG_CLKDIV_Pos );
;;;654        RCC_Clocks->PCLK0_Frequency = RCC_Clocks->HCLK_Frequency >> tmp;
;;;655    
;;;656        /* Get AHB source -------------------------------------------------------*/
;;;657        tmp = ( ( RCCAPB1->APB1_CFG & APB1_CFG_CLKDIV ) >> APB1_CFG_CLKDIV_Pos );
;;;658        RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> tmp;
;;;659    
;;;660        /* Get AHB source -------------------------------------------------------*/
;;;661        tmp = ( ( RCCAPB2->APB2_CFG & APB2_CFG_CLKDIV ) >> APB2_CFG_CLKDIV_Pos );
;;;662        RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> tmp;
;;;663    }
000040  0249              LSLS     r1,r1,#9
000042  0f4a              LSRS     r2,r1,#29
000044  6801              LDR      r1,[r0,#0]            ;650
000046  40d1              LSRS     r1,r1,r2              ;650
000048  4a0e              LDR      r2,|L18.132|
00004a  6041              STR      r1,[r0,#4]            ;653
00004c  6812              LDR      r2,[r2,#0]            ;653
00004e  460b              MOV      r3,r1
000050  0252              LSLS     r2,r2,#9
000052  0f52              LSRS     r2,r2,#29
000054  40d3              LSRS     r3,r3,r2              ;654
000056  4a0c              LDR      r2,|L18.136|
000058  6083              STR      r3,[r0,#8]            ;657
00005a  6812              LDR      r2,[r2,#0]            ;657
00005c  460b              MOV      r3,r1
00005e  0252              LSLS     r2,r2,#9
000060  0f52              LSRS     r2,r2,#29
000062  40d3              LSRS     r3,r3,r2              ;658
000064  4a09              LDR      r2,|L18.140|
000066  60c3              STR      r3,[r0,#0xc]          ;661
000068  6812              LDR      r2,[r2,#0]            ;661
00006a  0252              LSLS     r2,r2,#9
00006c  0f52              LSRS     r2,r2,#29
00006e  40d1              LSRS     r1,r1,r2              ;662
000070  6101              STR      r1,[r0,#0x10]         ;662
000072  4770              BX       lr
;;;664    
                          ENDP

                  |L18.116|
                          DCD      0x40003000
                  |L18.120|
                          DCD      0x01e84800
                  |L18.124|
                          DCD      0x00f42400
                  |L18.128|
                          DCD      0x03d09000
                  |L18.132|
                          DCD      0x40020000
                  |L18.136|
                          DCD      0x40021000
                  |L18.140|
                          DCD      0x40022000

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1202    */
;;;1203   FlagStatus RCC_GetFlagStatus ( uint32_t RCC_FLAG )
000000  4903              LDR      r1,|L19.16|
;;;1204   {
;;;1205       /* Check the parameters */
;;;1206       assert_param ( IS_GET_RCC_FLAG ( RCC_FLAG ) );
;;;1207   
;;;1208       if( ( RCC->RCC_STS & RCC_FLAG ) != ( uint32_t ) RESET )
000002  6a09              LDR      r1,[r1,#0x20]
000004  4201              TST      r1,r0
000006  d001              BEQ      |L19.12|
;;;1209       {
;;;1210           return ( SET );
000008  2001              MOVS     r0,#1
;;;1211       }
;;;1212       return ( RESET );
;;;1213   }
00000a  4770              BX       lr
                  |L19.12|
00000c  2000              MOVS     r0,#0                 ;1212
00000e  4770              BX       lr
;;;1214   
                          ENDP

                  |L19.16|
                          DCD      0x40003000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;484      */
;;;485    RCC_SYSCLKSource_TypeDef RCC_GetSYSCLKSource ( void )
000000  4805              LDR      r0,|L20.24|
;;;486    {
;;;487        if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) != RESET )
000002  6941              LDR      r1,[r0,#0x14]
000004  0609              LSLS     r1,r1,#24
000006  d504              BPL      |L20.18|
;;;488        {
;;;489            return ( ( RCC_SYSCLKSource_TypeDef ) ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSEL ) );
000008  6940              LDR      r0,[r0,#0x14]
00000a  2103              MOVS     r1,#3
00000c  0209              LSLS     r1,r1,#8
00000e  4008              ANDS     r0,r0,r1
;;;490        }
;;;491        else
;;;492        {
;;;493    #if defined (SC32f10xx)
;;;494            return RCC_SYSCLKSource_HIRC;
;;;495    #elif  defined (SC32f12xx)
;;;496            return RCC_SYSCLKSource_HIRC_2;
;;;497    #endif
;;;498        }
;;;499    
;;;500    }
000010  4770              BX       lr
                  |L20.18|
000012  4802              LDR      r0,|L20.28|
000014  4770              BX       lr
;;;501    
                          ENDP

000016  0000              DCW      0x0000
                  |L20.24|
                          DCD      0x40003000
                  |L20.28|
                          DCD      0x0000ff7f

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;511     */
;;;512    void RCC_HCLKConfig ( RCC_HCLK_TypeDef RCC_HCLK )
000000  4904              LDR      r1,|L21.20|
;;;513    {
;;;514        /* Check the parameters */
;;;515        assert_param ( IS_RCC_HCLK ( RCC_HCLK ) );
;;;516    
;;;517        RCCAHB->AHB_CFG &= ( uint32_t ) ~ ( AHB_CFG_CLKDIV );
000002  680a              LDR      r2,[r1,#0]
000004  2307              MOVS     r3,#7
000006  051b              LSLS     r3,r3,#20
000008  439a              BICS     r2,r2,r3
00000a  600a              STR      r2,[r1,#0]
;;;518        RCCAHB->AHB_CFG |= RCC_HCLK;
00000c  680a              LDR      r2,[r1,#0]
00000e  4302              ORRS     r2,r2,r0
000010  600a              STR      r2,[r1,#0]
;;;519    }
000012  4770              BX       lr
;;;520    
                          ENDP

                  |L21.20|
                          DCD      0x40003000

                          AREA ||i.RCC_HIRCCmd||, CODE, READONLY, ALIGN=2

                  RCC_HIRCCmd PROC
;;;135      */
;;;136    void RCC_HIRCCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;137    {
000002  4602              MOV      r2,r0
;;;138        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;139        if ( NewState != DISABLE )
;;;140        {
;;;141            /* Enable the selected HIRC peripheral */
;;;142            RCC->RCC_CFG0 |= RCC_CFG0_HIRCEN;
00000a  4905              LDR      r1,|L22.32|
00000c  2340              MOVS     r3,#0x40
;;;143        }
;;;144        else
;;;145        {
;;;146            /* Disable the selected HIRC peripheral */
;;;147            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_HIRCEN );
00000e  6948              LDR      r0,[r1,#0x14]
000010  2a00              CMP      r2,#0                 ;139
000012  d001              BEQ      |L22.24|
000014  4318              ORRS     r0,r0,r3              ;142
000016  e000              B        |L22.26|
                  |L22.24|
000018  4398              BICS     r0,r0,r3
                  |L22.26|
00001a  6148              STR      r0,[r1,#0x14]         ;142
;;;148        }
;;;149    }
00001c  bd00              POP      {pc}
;;;150    
                          ENDP

00001e  0000              DCW      0x0000
                  |L22.32|
                          DCD      0x40003000

                          AREA ||i.RCC_HIRCDIV1Cmd||, CODE, READONLY, ALIGN=2

                  RCC_HIRCDIV1Cmd PROC
;;;252    
;;;253    void RCC_HIRCDIV1Cmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;254    {
000002  4602              MOV      r2,r0
;;;255        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;256        if ( NewState != DISABLE )
;;;257        {
;;;258            /* Enable the selected HIRCDIV1 peripheral */
;;;259            RCC->RCC_CFG0 |= RCC_CFG0_HIRCDIV1;
00000a  4905              LDR      r1,|L23.32|
00000c  140b              ASRS     r3,r1,#16
;;;260        }
;;;261        else
;;;262        {
;;;263            /* Disable the selected HIRCDIV1 peripheral */
;;;264            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_HIRCDIV1 );
00000e  6948              LDR      r0,[r1,#0x14]
000010  2a00              CMP      r2,#0                 ;256
000012  d001              BEQ      |L23.24|
000014  4318              ORRS     r0,r0,r3              ;259
000016  e000              B        |L23.26|
                  |L23.24|
000018  4398              BICS     r0,r0,r3
                  |L23.26|
00001a  6148              STR      r0,[r1,#0x14]         ;259
;;;265        }
;;;266    }
00001c  bd00              POP      {pc}
;;;267    #endif
                          ENDP

00001e  0000              DCW      0x0000
                  |L23.32|
                          DCD      0x40003000

                          AREA ||i.RCC_HXTCmd||, CODE, READONLY, ALIGN=2

                  RCC_HXTCmd PROC
;;;113      */
;;;114    void RCC_HXTCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;115    {
000002  4602              MOV      r2,r0
;;;116        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;117        if ( NewState != DISABLE )
;;;118        {
;;;119            /* Enable the selected HXT peripheral */
;;;120            RCC->RCC_CFG0 |= RCC_CFG0_HXTEN;
00000a  4905              LDR      r1,|L24.32|
00000c  2320              MOVS     r3,#0x20
;;;121        }
;;;122        else
;;;123        {
;;;124            /* Disable the selected HXT peripheral */
;;;125            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_HXTEN );
00000e  6948              LDR      r0,[r1,#0x14]
000010  2a00              CMP      r2,#0                 ;117
000012  d001              BEQ      |L24.24|
000014  4318              ORRS     r0,r0,r3              ;120
000016  e000              B        |L24.26|
                  |L24.24|
000018  4398              BICS     r0,r0,r3
                  |L24.26|
00001a  6148              STR      r0,[r1,#0x14]         ;120
;;;126        }
;;;127    }
00001c  bd00              POP      {pc}
;;;128    
                          ENDP

00001e  0000              DCW      0x0000
                  |L24.32|
                          DCD      0x40003000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;1176     */
;;;1177   void RCC_ITConfig ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;1178   {
000002  4602              MOV      r2,r0
;;;1179       RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;1180       if ( NewState != DISABLE )
;;;1181       {
;;;1182           RCC->RCC_CFG0 |= RCC_CFG0_INTEN;
00000a  4905              LDR      r1,|L25.32|
00000c  13cb              ASRS     r3,r1,#15
;;;1183       }
;;;1184       else
;;;1185       {
;;;1186           RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_INTEN );
00000e  6948              LDR      r0,[r1,#0x14]
000010  2a00              CMP      r2,#0                 ;1180
000012  d001              BEQ      |L25.24|
000014  4318              ORRS     r0,r0,r3              ;1182
000016  e000              B        |L25.26|
                  |L25.24|
000018  4398              BICS     r0,r0,r3
                  |L25.26|
00001a  6148              STR      r0,[r1,#0x14]         ;1182
;;;1187       }
;;;1188   }
00001c  bd00              POP      {pc}
;;;1189   
                          ENDP

00001e  0000              DCW      0x0000
                  |L25.32|
                          DCD      0x40003000

                          AREA ||i.RCC_LCDLEDCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_LCDLEDCLKConfig PROC
;;;720     */
;;;721    void RCC_LCDLEDCLKConfig ( RCC_LCDLEDCLKSource_TypeDef RCC_LCDLEDCLKSource )
000000  b500              PUSH     {lr}
;;;722    {
000002  4603              MOV      r3,r0
;;;723        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;724        /* Check the parameters */
;;;725        assert_param ( RCC_LCDLEDCLKSOURCE ( RCC_LCDLEDCLKSource ) );
;;;726    
;;;727        RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_LCDCLKSEL );
00000a  4904              LDR      r1,|L26.28|
00000c  698a              LDR      r2,[r1,#0x18]
00000e  2002              MOVS     r0,#2
000010  4382              BICS     r2,r2,r0
000012  618a              STR      r2,[r1,#0x18]
;;;728        RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_LCDLEDCLKSource );
000014  698a              LDR      r2,[r1,#0x18]
000016  431a              ORRS     r2,r2,r3
000018  618a              STR      r2,[r1,#0x18]
;;;729    }
00001a  bd00              POP      {pc}
;;;730    #endif
                          ENDP

                  |L26.28|
                          DCD      0x40003000

                          AREA ||i.RCC_LIRCCmd||, CODE, READONLY, ALIGN=2

                  RCC_LIRCCmd PROC
;;;179      */
;;;180    void RCC_LIRCCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;181    {
000002  4602              MOV      r2,r0
;;;182        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;183        if ( NewState != DISABLE )
;;;184        {
;;;185            /* Enable the selected LIRC peripheral */
;;;186            RCC->RCC_CFG0 |= RCC_CFG0_LIRCEN;
00000a  4905              LDR      r1,|L27.32|
00000c  2302              MOVS     r3,#2
;;;187        }
;;;188        else
;;;189        {
;;;190            /* Disable the selected LIRC peripheral */
;;;191            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_LIRCEN );
00000e  6948              LDR      r0,[r1,#0x14]
000010  2a00              CMP      r2,#0                 ;183
000012  d001              BEQ      |L27.24|
000014  4318              ORRS     r0,r0,r3              ;186
000016  e000              B        |L27.26|
                  |L27.24|
000018  4398              BICS     r0,r0,r3
                  |L27.26|
00001a  6148              STR      r0,[r1,#0x14]         ;186
;;;192        }
;;;193    }
00001c  bd00              POP      {pc}
;;;194    
                          ENDP

00001e  0000              DCW      0x0000
                  |L27.32|
                          DCD      0x40003000

                          AREA ||i.RCC_LXTCmd||, CODE, READONLY, ALIGN=2

                  RCC_LXTCmd PROC
;;;157      */
;;;158    void RCC_LXTCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;159    {
000002  4602              MOV      r2,r0
;;;160        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;161        if ( NewState != DISABLE )
;;;162        {
;;;163            /* Enable the selected LXT peripheral */
;;;164            RCC->RCC_CFG0 |= RCC_CFG0_LXTEN;
00000a  4905              LDR      r1,|L28.32|
00000c  2a00              CMP      r2,#0                 ;161
;;;165        }
;;;166        else
;;;167        {
;;;168            /* Disable the selected LXT peripheral */
;;;169            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_LXTEN );
00000e  6948              LDR      r0,[r1,#0x14]
000010  d002              BEQ      |L28.24|
000012  2201              MOVS     r2,#1                 ;164
000014  4310              ORRS     r0,r0,r2              ;164
000016  e001              B        |L28.28|
                  |L28.24|
000018  0840              LSRS     r0,r0,#1
00001a  0040              LSLS     r0,r0,#1
                  |L28.28|
00001c  6148              STR      r0,[r1,#0x14]         ;164
;;;170        }
;;;171    }
00001e  bd00              POP      {pc}
;;;172    
                          ENDP

                  |L28.32|
                          DCD      0x40003000

                          AREA ||i.RCC_NMICmd||, CODE, READONLY, ALIGN=2

                  RCC_NMICmd PROC
;;;1041    */
;;;1042   void RCC_NMICmd ( uint32_t RCC_NMIPeriph, FunctionalState NewState )
000000  b510              PUSH     {r4,lr}
;;;1043   {
;;;1044       uint32_t temp;
;;;1045       /* Check the parameters */
;;;1046       assert_param ( IS_RCC_NMIPeriph ( RCC_NMIPeriph ) );
;;;1047   
;;;1048       temp = RCC->NMI_CFG;
000002  4b05              LDR      r3,|L29.24|
000004  6ada              LDR      r2,[r3,#0x2c]
;;;1049   
;;;1050       temp &= ( ~RCC_NMIPeriph );
;;;1051   
;;;1052       if ( NewState != DISABLE )
;;;1053       {
;;;1054           temp |= 0xA05F0000 | RCC_NMIPeriph;
000006  4c05              LDR      r4,|L29.28|
000008  4382              BICS     r2,r2,r0              ;1050
00000a  2900              CMP      r1,#0                 ;1052
00000c  d000              BEQ      |L29.16|
00000e  4302              ORRS     r2,r2,r0
                  |L29.16|
;;;1055       }
;;;1056       else
;;;1057       {
;;;1058           temp |= 0xA05F0000;
000010  4322              ORRS     r2,r2,r4
;;;1059       }
;;;1060       RCC->NMI_CFG = temp;
000012  62da              STR      r2,[r3,#0x2c]
;;;1061   }
000014  bd10              POP      {r4,pc}
;;;1062   /* End of RCC_Group3.	*/
                          ENDP

000016  0000              DCW      0x0000
                  |L29.24|
                          DCD      0x40003000
                  |L29.28|
                          DCD      0xa05f0000

                          AREA ||i.RCC_PWM0CLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_PWM0CLKConfig PROC
;;;702     */
;;;703    void RCC_PWM0CLKConfig ( RCC_PWM0CLKSource_TypeDef RCC_PWM0CLKSource )
000000  b500              PUSH     {lr}
;;;704    {
000002  4603              MOV      r3,r0
;;;705        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;706        /* Check the parameters */
;;;707        assert_param ( RCC_PWM0CLKSOURCE ( RCC_PWM0CLKSource ) );
;;;708    
;;;709        RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_PWM0CLKSEL );
00000a  4904              LDR      r1,|L30.28|
00000c  698a              LDR      r2,[r1,#0x18]
00000e  2004              MOVS     r0,#4
000010  4382              BICS     r2,r2,r0
000012  618a              STR      r2,[r1,#0x18]
;;;710        RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_PWM0CLKSource );
000014  698a              LDR      r2,[r1,#0x18]
000016  431a              ORRS     r2,r2,r3
000018  618a              STR      r2,[r1,#0x18]
;;;711    }
00001a  bd00              POP      {pc}
;;;712    #endif
                          ENDP

                  |L30.28|
                          DCD      0x40003000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;390     */
;;;391    ErrorStatus RCC_SYSCLKConfig ( RCC_SYSCLKSource_TypeDef RCC_SYSCLKSource )
000000  b530              PUSH     {r4,r5,lr}
;;;392    {
000002  4603              MOV      r3,r0
;;;393        uint32_t tmpreg;
;;;394        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;395    
;;;396        /* Check the parameters */
;;;397        assert_param ( IS_RCC_SYSCLKSOURCE ( RCC_SYSCLKSource ) );
;;;398    	
;;;399    		tmpreg = RCC->RCC_CFG0;
00000a  4a19              LDR      r2,|L31.112|
00000c  6950              LDR      r0,[r2,#0x14]
;;;400    	
;;;401    		tmpreg &= ( uint32_t ) ~ RCC_CFG0_WAIT_Msk;
00000e  2403              MOVS     r4,#3
000010  0324              LSLS     r4,r4,#12
000012  43a0              BICS     r0,r0,r4
;;;402    	
;;;403    		tmpreg |= ( uint32_t ) RCC_WAIT_3;
000014  4320              ORRS     r0,r0,r4
;;;404    	
;;;405    		RCC->RCC_CFG0 = tmpreg;
000016  6150              STR      r0,[r2,#0x14]
;;;406    	
;;;407        if ( RCC_SYSCLKSource != ( ( uint16_t ) ( ~RCC_CFG0_SYSCLKSW ) ) )
000018  4816              LDR      r0,|L31.116|
;;;408        {
;;;409    		    RCC_Unlock ( 0xFF );
;;;410    				
;;;411            tmpreg = RCC->RCC_CFG0;
;;;412    
;;;413            tmpreg &= ( uint32_t ) ~ ( RCC_CFG0_SYSCLKSEL | RCC_CFG0_SYSCLKSW );
;;;414    
;;;415            tmpreg |= ( uint32_t ) RCC_SYSCLKSource;
;;;416    
;;;417            RCC->RCC_CFG0 = tmpreg;
;;;418    
;;;419            RCC->RCC_CFG0 |= RCC_CFG0_SYSCLKSW;
00001a  2580              MOVS     r5,#0x80
00001c  4283              CMP      r3,r0                 ;407
00001e  d018              BEQ      |L31.82|
000020  20ff              MOVS     r0,#0xff              ;409
000022  f7fffffe          BL       RCC_Unlock
000026  6950              LDR      r0,[r2,#0x14]         ;411
000028  2107              MOVS     r1,#7                 ;413
00002a  01c9              LSLS     r1,r1,#7              ;413
00002c  4388              BICS     r0,r0,r1              ;413
00002e  4318              ORRS     r0,r0,r3              ;415
000030  6150              STR      r0,[r2,#0x14]         ;417
000032  6950              LDR      r0,[r2,#0x14]
000034  4328              ORRS     r0,r0,r5
000036  6150              STR      r0,[r2,#0x14]
;;;420    
;;;421            if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) != RESET )
000038  6950              LDR      r0,[r2,#0x14]
00003a  0600              LSLS     r0,r0,#24
00003c  d516              BPL      |L31.108|
;;;422    				{
;;;423    #if defined(SC32f12xx)
;;;424    						if ( RCC_SYSCLKSource == RCC_SYSCLKSource_HIRC )
00003e  1fd8              SUBS     r0,r3,#7
000040  38ff              SUBS     r0,r0,#0xff
000042  38fa              SUBS     r0,r0,#0xfa
000044  d103              BNE      |L31.78|
;;;425    						{
;;;426    								tmpreg = RCC->RCC_CFG0;
000046  6950              LDR      r0,[r2,#0x14]
;;;427    								tmpreg &= ( uint32_t ) ~ RCC_CFG0_WAIT_Msk;
000048  43a0              BICS     r0,r0,r4
;;;428    								tmpreg |= ( uint32_t ) RCC_WAIT_2;
00004a  01a9              LSLS     r1,r5,#6
;;;429    								RCC->RCC_CFG0 = tmpreg;
00004c  e00b              B        |L31.102|
                  |L31.78|
;;;430    						}
;;;431    #elif defined(SC32f10xx)
;;;432    						uint32_t Multioperator = 1;
;;;433    						for ( int i = 1; i <= ((RCC->PLL_CFG &0x03) + 1 ); i++ )
;;;434    						{
;;;435    								Multioperator *=  2;
;;;436    						}
;;;437    						if ( ( ( 2 * ((RCC->PLL_CFG &0xFF00)>>8) ) / Multioperator ) >= 64 )
;;;438    						{
;;;439    								tmpreg = RCC->RCC_CFG0;
;;;440    								tmpreg &= ( uint32_t ) ~ RCC_CFG0_WAIT_Msk;
;;;441    								tmpreg |= ( uint32_t ) RCC_WAIT_1;
;;;442    							  RCC->RCC_CFG0 = tmpreg;
;;;443    						}
;;;444    #endif
;;;445    						return SUCCESS;
00004e  2000              MOVS     r0,#0
;;;446    					}
;;;447    					else
;;;448    					{
;;;449    						 return ERROR;
;;;450    					}
;;;451        }
;;;452        else
;;;453        {
;;;454            RCC->RCC_CFG0 &= ( uint32_t ) ~RCC_CFG0_SYSCLKSW;
;;;455    
;;;456            if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) == RESET )
;;;457    				{
;;;458    						tmpreg = RCC->RCC_CFG0;
;;;459    						tmpreg &= ( uint32_t ) ~ RCC_CFG0_WAIT_Msk;
;;;460    						tmpreg |= ( uint32_t ) RCC_WAIT_1;
;;;461    						RCC->RCC_CFG0 = tmpreg;
;;;462    					
;;;463    						return SUCCESS;
;;;464    				}
;;;465            else
;;;466    				{
;;;467                return ERROR;
;;;468    				}
;;;469        }
;;;470    }
000050  bd30              POP      {r4,r5,pc}
                  |L31.82|
000052  6950              LDR      r0,[r2,#0x14]         ;454
000054  43a8              BICS     r0,r0,r5              ;454
000056  6150              STR      r0,[r2,#0x14]         ;454
000058  6950              LDR      r0,[r2,#0x14]         ;456
00005a  0600              LSLS     r0,r0,#24             ;456
00005c  d406              BMI      |L31.108|
00005e  6950              LDR      r0,[r2,#0x14]         ;458
000060  2101              MOVS     r1,#1                 ;460
000062  43a0              BICS     r0,r0,r4              ;459
000064  0309              LSLS     r1,r1,#12             ;460
                  |L31.102|
000066  4308              ORRS     r0,r0,r1              ;460
000068  6150              STR      r0,[r2,#0x14]         ;461
00006a  e7f0              B        |L31.78|
                  |L31.108|
00006c  2001              MOVS     r0,#1                 ;467
00006e  bd30              POP      {r4,r5,pc}
;;;471    
                          ENDP

                  |L31.112|
                          DCD      0x40003000
                  |L31.116|
                          DCD      0x0000ff7f

                          AREA ||i.RCC_SystickCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SystickCLKConfig PROC
;;;1085    */
;;;1086   void RCC_SystickCLKConfig ( RCC_SysTickSource_TypeDef RCC_SysTickSource )
000000  b510              PUSH     {r4,lr}
;;;1087   {
;;;1088   
;;;1089       /* Check the parameters */
;;;1090       assert_param ( IS_RCC_SYSTICKSOURCE ( RCC_SysTickSource ) );
;;;1091   
;;;1092       if ( RCC_SysTickSource == RCC_SysTickSource_HCLK )
;;;1093       {
;;;1094           SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
000002  4c0c              LDR      r4,|L32.52|
000004  2304              MOVS     r3,#4
000006  4602              MOV      r2,r0                 ;1087
000008  2801              CMP      r0,#1                 ;1092
00000a  d00e              BEQ      |L32.42|
;;;1095       }
;;;1096       else
;;;1097       {
;;;1098           RCC_Unlock ( 0xFF );
00000c  20ff              MOVS     r0,#0xff
00000e  f7fffffe          BL       RCC_Unlock
;;;1099           SysTick->CTRL &= ~SysTick_CTRL_CLKSOURCE_Msk;
000012  6920              LDR      r0,[r4,#0x10]
000014  4398              BICS     r0,r0,r3
000016  6120              STR      r0,[r4,#0x10]
;;;1100           RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_STCLKSEL );
000018  4907              LDR      r1,|L32.56|
00001a  6988              LDR      r0,[r1,#0x18]
00001c  23e0              MOVS     r3,#0xe0
00001e  4398              BICS     r0,r0,r3
000020  6188              STR      r0,[r1,#0x18]
;;;1101           RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_SysTickSource );
000022  6988              LDR      r0,[r1,#0x18]
000024  4310              ORRS     r0,r0,r2
000026  6188              STR      r0,[r1,#0x18]
;;;1102       }
;;;1103   }
000028  bd10              POP      {r4,pc}
                  |L32.42|
00002a  6920              LDR      r0,[r4,#0x10]         ;1094
00002c  4318              ORRS     r0,r0,r3              ;1094
00002e  6120              STR      r0,[r4,#0x10]         ;1094
000030  bd10              POP      {r4,pc}
;;;1104   /**
                          ENDP

000032  0000              DCW      0x0000
                  |L32.52|
                          DCD      0xe000e000
                  |L32.56|
                          DCD      0x40003000

                          AREA ||i.RCC_SystickCmd||, CODE, READONLY, ALIGN=2

                  RCC_SystickCmd PROC
;;;1123     */
;;;1124   void RCC_SystickCmd ( FunctionalState NewState )
000000  4905              LDR      r1,|L33.24|
;;;1125   {
;;;1126       /* Check the parameters */
;;;1127       assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;1128   
;;;1129       if ( NewState != DISABLE )
000002  2800              CMP      r0,#0
;;;1130       {
;;;1131           SysTick->CTRL |= ( uint32_t ) ( SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk ); /* Enable SysTick IRQ and SysTick Timer */
;;;1132       }
;;;1133       else
;;;1134       {
;;;1135           SysTick->CTRL &= ~ ( uint32_t ) ( SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk );
000004  6908              LDR      r0,[r1,#0x10]
000006  d002              BEQ      |L33.14|
000008  2203              MOVS     r2,#3                 ;1131
00000a  4310              ORRS     r0,r0,r2              ;1131
00000c  e001              B        |L33.18|
                  |L33.14|
00000e  0880              LSRS     r0,r0,#2
000010  0080              LSLS     r0,r0,#2
                  |L33.18|
000012  6108              STR      r0,[r1,#0x10]         ;1131
;;;1136       }
;;;1137   }
000014  4770              BX       lr
;;;1138   /**
                          ENDP

000016  0000              DCW      0x0000
                  |L33.24|
                          DCD      0xe000e000

                          AREA ||i.RCC_SystickGetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_SystickGetFlagStatus PROC
;;;1144    */
;;;1145   FlagStatus RCC_SystickGetFlagStatus ( void )
000000  4803              LDR      r0,|L34.16|
;;;1146   {
;;;1147       if ( ( SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk ) != ( uint32_t ) RESET )
000002  6900              LDR      r0,[r0,#0x10]
000004  03c0              LSLS     r0,r0,#15
000006  d501              BPL      |L34.12|
;;;1148       {
;;;1149           return ( SET );
000008  2001              MOVS     r0,#1
;;;1150       }
;;;1151       return ( RESET );
;;;1152   }
00000a  4770              BX       lr
                  |L34.12|
00000c  2000              MOVS     r0,#0                 ;1151
00000e  4770              BX       lr
;;;1153   /**
                          ENDP

                  |L34.16|
                          DCD      0xe000e000

                          AREA ||i.RCC_SystickSetCounter||, CODE, READONLY, ALIGN=2

                  RCC_SystickSetCounter PROC
;;;1108    */
;;;1109   void RCC_SystickSetCounter ( uint32_t Counter )
000000  4904              LDR      r1,|L35.20|
;;;1110   {
;;;1111       if ( ( Counter - 1UL ) <= SysTick_LOAD_RELOAD_Msk ) /* Reload value possible */
000002  1e40              SUBS     r0,r0,#1
000004  4288              CMP      r0,r1
000006  d803              BHI      |L35.16|
;;;1112       {
;;;1113           SysTick->LOAD = ( uint32_t ) ( Counter - 1UL ); /* set reload register */
000008  4903              LDR      r1,|L35.24|
00000a  6148              STR      r0,[r1,#0x14]
;;;1114           SysTick->VAL  = 0UL;   /* Load the SysTick Counter Value */
00000c  2000              MOVS     r0,#0
00000e  6188              STR      r0,[r1,#0x18]
                  |L35.16|
;;;1115       }
;;;1116   }
000010  4770              BX       lr
;;;1117   /**
                          ENDP

000012  0000              DCW      0x0000
                  |L35.20|
                          DCD      0x00ffffff
                  |L35.24|
                          DCD      0xe000e000

                          AREA ||i.RCC_Unlock||, CODE, READONLY, ALIGN=2

                  RCC_Unlock PROC
;;;93      */
;;;94     ErrorStatus RCC_Unlock ( uint8_t TimeLimit )
000000  2840              CMP      r0,#0x40
;;;95     {
000002  d303              BCC      |L36.12|
;;;96         if ( TimeLimit >= 0x40 )
;;;97         {
;;;98             RCC->RCC_KEY = TimeLimit;
000004  4902              LDR      r1,|L36.16|
000006  60c8              STR      r0,[r1,#0xc]
;;;99             return SUCCESS;
000008  2000              MOVS     r0,#0
;;;100        }
;;;101        else
;;;102        {
;;;103            return ERROR;
;;;104        }
;;;105    }
00000a  4770              BX       lr
                  |L36.12|
00000c  2001              MOVS     r0,#1                 ;103
00000e  4770              BX       lr
;;;106    
                          ENDP

                  |L36.16|
                          DCD      0x40003000

                          AREA ||i.RCC_WaitConfig||, CODE, READONLY, ALIGN=2

                  RCC_WaitConfig PROC
;;;673     */
;;;674    void RCC_WaitConfig ( RCC_Wait_TypeDef RCC_Wait )
000000  b500              PUSH     {lr}
;;;675    {
000002  4603              MOV      r3,r0
;;;676        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;677        /* Check the parameters */
;;;678        assert_param ( IS_RCC_Wait ( RCC_Wait ) );
;;;679    
;;;680        RCC->RCC_CFG0 &= ~RCC_CFG0_WAIT_Msk;
00000a  4905              LDR      r1,|L37.32|
00000c  694a              LDR      r2,[r1,#0x14]
00000e  2003              MOVS     r0,#3
000010  0300              LSLS     r0,r0,#12
000012  4382              BICS     r2,r2,r0
000014  614a              STR      r2,[r1,#0x14]
;;;681        RCC->RCC_CFG0 |= RCC_Wait;
000016  694a              LDR      r2,[r1,#0x14]
000018  431a              ORRS     r2,r2,r3
00001a  614a              STR      r2,[r1,#0x14]
;;;682    
;;;683    }
00001c  bd00              POP      {pc}
;;;684    /** @defgroup RCC_Group3 Peripheral clocks configuration functions
                          ENDP

00001e  0000              DCW      0x0000
                  |L37.32|
                          DCD      0x40003000

                          AREA ||i.SC_Delay||, CODE, READONLY, ALIGN=2

                  SC_Delay PROC
;;;1268     */
;;;1269   void SC_Delay(uint32_t ms_Delay)
000000  4a07              LDR      r2,|L38.32|
;;;1270   {
;;;1271   		uint32_t tickstart = uwTick;
000002  6811              LDR      r1,[r2,#0]  ; uwTick
;;;1272   		uint32_t tickend = tickstart + ms_Delay;
000004  1808              ADDS     r0,r1,r0
;;;1273   		if(tickend < tickstart)
000006  4288              CMP      r0,r1
000008  d206              BCS      |L38.24|
                  |L38.10|
;;;1274   		{
;;;1275   			while(uwTick >= tickstart || uwTick < tickend);
00000a  6813              LDR      r3,[r2,#0]  ; uwTick
00000c  428b              CMP      r3,r1
00000e  d2fc              BCS      |L38.10|
000010  6813              LDR      r3,[r2,#0]  ; uwTick
000012  4283              CMP      r3,r0
000014  d3f9              BCC      |L38.10|
;;;1276   		}
;;;1277   		else
;;;1278   		{
;;;1279   			while (uwTick < tickend);
;;;1280   		}
;;;1281   }
000016  4770              BX       lr
                  |L38.24|
000018  6811              LDR      r1,[r2,#0]            ;1279  ; uwTick
00001a  4281              CMP      r1,r0                 ;1279
00001c  d3fc              BCC      |L38.24|
00001e  4770              BX       lr
;;;1282   
                          ENDP

                  |L38.32|
                          DCD      ||.data||

                          AREA ||i.SC_Delay_us||, CODE, READONLY, ALIGN=2

                  SC_Delay_us PROC
;;;1298     */
;;;1299   void SC_Delay_us(uint32_t us_Delay,uint32_t Sys_freq)
000000  b510              PUSH     {r4,lr}
;;;1300   {
000002  4604              MOV      r4,r0
;;;1301   		if(us_Delay < SC_MAX_DELAY && us_Delay >= 10)
000004  380a              SUBS     r0,r0,#0xa
000006  220b              MOVS     r2,#0xb
000008  460b              MOV      r3,r1                 ;1300
00000a  42d0              CMN      r0,r2
00000c  d20e              BCS      |L39.44|
;;;1302   		{
;;;1303   			SysTick->LOAD = ( uint32_t ) ((us_Delay-2)* (Sys_freq/1000000));
00000e  4908              LDR      r1,|L39.48|
000010  4618              MOV      r0,r3
000012  f7fffffe          BL       __aeabi_uidivmod
000016  1ea4              SUBS     r4,r4,#2
000018  4906              LDR      r1,|L39.52|
00001a  4360              MULS     r0,r4,r0
00001c  6148              STR      r0,[r1,#0x14]
;;;1304   			SysTick->VAL=0UL;
00001e  2000              MOVS     r0,#0
000020  6188              STR      r0,[r1,#0x18]
;;;1305   			uint32_t tickstart = uwTick;
000022  4805              LDR      r0,|L39.56|
000024  6801              LDR      r1,[r0,#0]  ; uwTick
                  |L39.38|
;;;1306   			while(uwTick==tickstart);
000026  6802              LDR      r2,[r0,#0]  ; uwTick
000028  428a              CMP      r2,r1
00002a  d0fc              BEQ      |L39.38|
                  |L39.44|
;;;1307   		}
;;;1308   }
00002c  bd10              POP      {r4,pc}
;;;1309   
                          ENDP

00002e  0000              DCW      0x0000
                  |L39.48|
                          DCD      0x000f4240
                  |L39.52|
                          DCD      0xe000e000
                  |L39.56|
                          DCD      ||.data||

                          AREA ||i.SC_IncTick||, CODE, READONLY, ALIGN=2

                  SC_IncTick PROC
;;;1253     */
;;;1254   void SC_IncTick(void)
000000  4802              LDR      r0,|L40.12|
;;;1255   {
;;;1256     uwTick++;
000002  6801              LDR      r1,[r0,#0]  ; uwTick
000004  1c49              ADDS     r1,r1,#1
000006  6001              STR      r1,[r0,#0]  ; uwTick
;;;1257   }
000008  4770              BX       lr
;;;1258   
                          ENDP

00000a  0000              DCW      0x0000
                  |L40.12|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  uwTick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_rcc_c_49e27980____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_rcc_c_49e27980____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_rcc_c_49e27980____REVSH|
#line 478
|__asm___15_sc32f1xxx_rcc_c_49e27980____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
