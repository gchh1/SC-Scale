; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_tim.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_tim.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Algorithm -IC:\Users\gchh\AppData\Local\Arm\Packs\Keil\SC32F1xxx_DFP\1.1.7\Device\SC32F12xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=543 -DSC32f12xx -DSC32f12xx -DPrintfEable --omf_browse=..\output\sc32f1xxx_tim.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_tim.c]
                          THUMB

                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;936     */
;;;937    void TIM_ClearFlag ( TIM_TypeDef* TIMx, uint16_t TIM_FLAG )
000000  60c1              STR      r1,[r0,#0xc]
;;;938    {
;;;939        /* Check the parameters */
;;;940        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;941    
;;;942        /* Clear the flags */
;;;943        TIMx->TIM_STS = ( uint16_t ) TIM_FLAG;
;;;944    }
000002  4770              BX       lr
;;;945    
                          ENDP


                          AREA ||i.TIM_ClockOutputCmd||, CODE, READONLY, ALIGN=1

                  TIM_ClockOutputCmd PROC
;;;756     */
;;;757    void TIM_ClockOutputCmd ( TIM_TypeDef* TIMx, FunctionalState NewState )
000000  2201              MOVS     r2,#1
;;;758    {
;;;759        /* Check the parameters */
;;;760        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;761        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;762    
;;;763        if ( NewState != DISABLE )
;;;764        {
;;;765            /* Enable the TIM Clock Output */
;;;766            TIMx->TIM_CON |= TIM_CON_TXOE;
000002  03d2              LSLS     r2,r2,#15
000004  2900              CMP      r1,#0                 ;763
;;;767        }
;;;768        else
;;;769        {
;;;770            /* Disable the TIM Clock Output */
;;;771            TIMx->TIM_CON &= ( uint32_t ) ~TIM_CON_TXOE;
000006  6801              LDR      r1,[r0,#0]
000008  d001              BEQ      |L2.14|
00000a  4311              ORRS     r1,r1,r2              ;766
00000c  e000              B        |L2.16|
                  |L2.14|
00000e  4391              BICS     r1,r1,r2
                  |L2.16|
000010  6001              STR      r1,[r0,#0]            ;766
;;;772        }
;;;773    }
000012  4770              BX       lr
;;;774    
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=2

                  TIM_Cmd PROC
;;;180     */
;;;181    void TIM_Cmd ( TIM_TypeDef* TIMx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;182    {
;;;183        /* Check the parameters */
;;;184        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;185        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;186    
;;;187        if ( NewState != DISABLE )
;;;188        {
;;;189            /* Enable the TIM Counter */
;;;190            TIMx->TIM_CON |= TIM_CON_TR;
;;;191        }
;;;192        else
;;;193        {
;;;194            /* Disable the TIM Counter */
;;;195            TIMx->TIM_CON &= ( uint16_t ) ~TIM_CON_TR;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  2280              MOVS     r2,#0x80              ;190
000008  4311              ORRS     r1,r1,r2              ;190
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  4a01              LDR      r2,|L3.20|
00000e  4011              ANDS     r1,r1,r2
                  |L3.16|
000010  6001              STR      r1,[r0,#0]            ;190
;;;196        }
;;;197    }
000012  4770              BX       lr
;;;198    
                          ENDP

                  |L3.20|
                          DCD      0x0000ff7f

                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;967     */
;;;968    void TIM_DMACmd ( TIM_TypeDef* TIMx, uint16_t TIM_DMAReq, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;969    {
;;;970        /* Check the parameters */
;;;971        assert_param ( IS_TIM_DMA_PERIPH ( TIMx ) );
;;;972        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;973    
;;;974        if ( NewState != DISABLE )
;;;975        {
;;;976            /* Enable the TIM DMA */
;;;977            TIMx->TIM_IDE |= TIM_DMAReq;
;;;978        }
;;;979        else
;;;980        {
;;;981            /* Disable the TIM DMA */
;;;982            TIMx->TIM_IDE &= ( uint16_t ) ~TIM_DMAReq;
000002  6982              LDR      r2,[r0,#0x18]
000004  d001              BEQ      |L4.10|
000006  430a              ORRS     r2,r2,r1              ;977
000008  e002              B        |L4.16|
                  |L4.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L4.16|
000010  6182              STR      r2,[r0,#0x18]         ;977
;;;983        }
;;;984    }
000012  4770              BX       lr
;;;985    
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;54      */
;;;55     void TIM_DeInit ( TIM_TypeDef* TIMx )
000000  492d              LDR      r1,|L5.184|
;;;56     {
000002  b510              PUSH     {r4,lr}
;;;57         assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;58     
;;;59         if ( TIMx == TIM0 )
000004  4288              CMP      r0,r1
000006  d106              BNE      |L5.22|
;;;60         {
;;;61             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM0, ENABLE );
000008  2101              MOVS     r1,#1
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;62             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM0, DISABLE );
000010  2100              MOVS     r1,#0
000012  2001              MOVS     r0,#1
000014  e009              B        |L5.42|
                  |L5.22|
;;;63         }
;;;64         else if ( TIMx == TIM1 )
000016  4928              LDR      r1,|L5.184|
000018  3140              ADDS     r1,r1,#0x40
00001a  4288              CMP      r0,r1
00001c  d108              BNE      |L5.48|
;;;65         {
;;;66             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM1, ENABLE );
00001e  2101              MOVS     r1,#1
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;67             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM1, DISABLE );
000026  2100              MOVS     r1,#0
000028  2002              MOVS     r0,#2
                  |L5.42|
00002a  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;68         }
;;;69         else if ( TIMx == TIM2 )
;;;70         {
;;;71             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM2, ENABLE );
;;;72             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM2, DISABLE );
;;;73         }
;;;74     
;;;75         else if ( TIMx == TIM3 )
;;;76         {
;;;77             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM3, ENABLE );
;;;78             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM3, DISABLE );
;;;79         }
;;;80         else if ( TIMx == TIM4 )
;;;81         {
;;;82             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM4, ENABLE );
;;;83             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM4, DISABLE );
;;;84         }
;;;85         else if ( TIMx == TIM5 )
;;;86         {
;;;87             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM5, ENABLE );
;;;88             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM5, DISABLE );
;;;89         }
;;;90         else if ( TIMx == TIM6 )
;;;91         {
;;;92             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM6, ENABLE );
;;;93             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM6, DISABLE );
;;;94         }
;;;95         else if ( TIMx == TIM7 )
;;;96         {
;;;97             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM7, ENABLE );
;;;98             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM7, DISABLE );
;;;99         }
;;;100    }
00002e  bd10              POP      {r4,pc}
                  |L5.48|
000030  4921              LDR      r1,|L5.184|
000032  3180              ADDS     r1,r1,#0x80           ;69
000034  4288              CMP      r0,r1                 ;69
000036  d106              BNE      |L5.70|
000038  2101              MOVS     r1,#1                 ;71
00003a  2004              MOVS     r0,#4                 ;71
00003c  f7fffffe          BL       RCC_APB0PeriphResetCmd
000040  2100              MOVS     r1,#0                 ;72
000042  2004              MOVS     r0,#4                 ;72
000044  e7f1              B        |L5.42|
                  |L5.70|
000046  491c              LDR      r1,|L5.184|
000048  31c0              ADDS     r1,r1,#0xc0           ;75
00004a  4288              CMP      r0,r1                 ;75
00004c  d106              BNE      |L5.92|
00004e  2101              MOVS     r1,#1                 ;77
000050  2008              MOVS     r0,#8                 ;77
000052  f7fffffe          BL       RCC_APB0PeriphResetCmd
000056  2100              MOVS     r1,#0                 ;78
000058  2008              MOVS     r0,#8                 ;78
00005a  e7e6              B        |L5.42|
                  |L5.92|
00005c  4917              LDR      r1,|L5.188|
00005e  4288              CMP      r0,r1                 ;80
000060  d106              BNE      |L5.112|
000062  2101              MOVS     r1,#1                 ;82
000064  4608              MOV      r0,r1                 ;82
000066  f7fffffe          BL       RCC_APB1PeriphResetCmd
00006a  2100              MOVS     r1,#0                 ;83
00006c  2001              MOVS     r0,#1                 ;83
00006e  e009              B        |L5.132|
                  |L5.112|
000070  4912              LDR      r1,|L5.188|
000072  3140              ADDS     r1,r1,#0x40           ;85
000074  4288              CMP      r0,r1                 ;85
000076  d108              BNE      |L5.138|
000078  2101              MOVS     r1,#1                 ;87
00007a  2002              MOVS     r0,#2                 ;87
00007c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000080  2100              MOVS     r1,#0                 ;88
000082  2002              MOVS     r0,#2                 ;88
                  |L5.132|
000084  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L5.136|
000088  bd10              POP      {r4,pc}
                  |L5.138|
00008a  490c              LDR      r1,|L5.188|
00008c  3180              ADDS     r1,r1,#0x80           ;90
00008e  4288              CMP      r0,r1                 ;90
000090  d106              BNE      |L5.160|
000092  2101              MOVS     r1,#1                 ;92
000094  2004              MOVS     r0,#4                 ;92
000096  f7fffffe          BL       RCC_APB1PeriphResetCmd
00009a  2100              MOVS     r1,#0                 ;93
00009c  2004              MOVS     r0,#4                 ;93
00009e  e7f1              B        |L5.132|
                  |L5.160|
0000a0  4906              LDR      r1,|L5.188|
0000a2  31c0              ADDS     r1,r1,#0xc0           ;95
0000a4  4288              CMP      r0,r1                 ;95
0000a6  d1ef              BNE      |L5.136|
0000a8  2101              MOVS     r1,#1                 ;97
0000aa  2008              MOVS     r0,#8                 ;97
0000ac  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000b0  2100              MOVS     r1,#0                 ;98
0000b2  2008              MOVS     r0,#8                 ;98
0000b4  e7e6              B        |L5.132|
;;;101    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L5.184|
                          DCD      0x40020100
                  |L5.188|
                          DCD      0x40021100

                          AREA ||i.TIM_GetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_GetAutoreload PROC
;;;287     */
;;;288    uint16_t TIM_GetAutoreload ( TIM_TypeDef* TIMx )
000000  6880              LDR      r0,[r0,#8]
;;;289    {
;;;290        /* Check the parameters */
;;;291        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;292    
;;;293        /* Get the ReloadData Register value */
;;;294        return TIMx->TIM_RLD;
000002  b280              UXTH     r0,r0
;;;295    }
000004  4770              BX       lr
;;;296    
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;238     */
;;;239    uint32_t TIM_GetCounter ( TIM_TypeDef* TIMx )
000000  6840              LDR      r0,[r0,#4]
;;;240    {
;;;241        /* Check the parameters */
;;;242        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;243    
;;;244        /* Get the Counter Register value */
;;;245        return TIMx->TIM_CNT;
;;;246    }
000002  4770              BX       lr
;;;247    
                          ENDP


                          AREA ||i.TIM_GetFailingCapture||, CODE, READONLY, ALIGN=1

                  TIM_GetFailingCapture PROC
;;;528      */
;;;529    uint32_t TIM_GetFailingCapture ( TIM_TypeDef* TIMx )
000000  6940              LDR      r0,[r0,#0x14]
;;;530    {
;;;531        /* Check the parameters */
;;;532        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;533    
;;;534        /* Get the Failing Capture Register value */
;;;535        return TIMx->TIM_PDTB_FCAP;
;;;536    }
000002  4770              BX       lr
;;;537    
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;899     */
;;;900    FlagStatus TIM_GetFlagStatus ( TIM_TypeDef* TIMx, TIM_Flag_TypeDef TIM_FLAG )
000000  4602              MOV      r2,r0
;;;901    {
;;;902        FlagStatus bitstatus = RESET;
;;;903        /* Check the parameters */
;;;904        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;905        assert_param ( IS_GET_TIM_FLAG ( TIM_FLAG ) );
;;;906    
;;;907        if ( ( TIMx->TIM_STS & TIM_FLAG ) != ( uint16_t ) RESET )
000002  68d2              LDR      r2,[r2,#0xc]
000004  2000              MOVS     r0,#0                 ;902
000006  420a              TST      r2,r1
000008  d000              BEQ      |L9.12|
;;;908        {
;;;909            bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L9.12|
;;;910        }
;;;911        else
;;;912        {
;;;913            bitstatus = RESET;
;;;914        }
;;;915        return bitstatus;
;;;916    }
00000c  4770              BX       lr
;;;917    
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;357     */
;;;358    TIM_Prescaler_TypeDef TIM_GetPrescaler ( TIM_TypeDef* TIMx )
000000  6800              LDR      r0,[r0,#0]
;;;359    {
;;;360        /* Check the parameters */
;;;361        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;362    
;;;363        /* Get the CKD value */
;;;364        return ( TIM_Prescaler_TypeDef ) ( TIMx->TIM_CON & TIM_CON_TIMCLK );
000002  2107              MOVS     r1,#7
000004  0209              LSLS     r1,r1,#8
000006  4008              ANDS     r0,r0,r1
;;;365    }
000008  4770              BX       lr
;;;366    
                          ENDP


                          AREA ||i.TIM_GetRisingCapture||, CODE, READONLY, ALIGN=1

                  TIM_GetRisingCapture PROC
;;;504      */
;;;505    uint32_t TIM_GetRisingCapture ( TIM_TypeDef* TIMx )
000000  6900              LDR      r0,[r0,#0x10]
;;;506    {
;;;507        /* Check the parameters */
;;;508        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;509    
;;;510        /* Get the Rising Capture Register value */
;;;511        return TIMx->TIM_PDTA_RCAP;
;;;512    }
000002  4770              BX       lr
;;;513    
                          ENDP


                          AREA ||i.TIM_ICCmd||, CODE, READONLY, ALIGN=2

                  TIM_ICCmd PROC
;;;471     */
;;;472    void TIM_ICCmd ( TIM_TypeDef* TIMx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;473    {
;;;474        /* Check the parameters */
;;;475        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;476        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;477    
;;;478        if ( NewState != DISABLE )
;;;479        {
;;;480            /* Enable the capture function of TIMx */
;;;481            TIMx->TIM_CON |= TIM_CON_CPRL;
;;;482        }
;;;483        else
;;;484        {
;;;485            /* Disable the capture function of TIMx */
;;;486            TIMx->TIM_CON &= ( uint16_t ) ~TIM_CON_CPRL;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L12.12|
000006  2201              MOVS     r2,#1                 ;481
000008  4311              ORRS     r1,r1,r2              ;481
00000a  e001              B        |L12.16|
                  |L12.12|
00000c  4a01              LDR      r2,|L12.20|
00000e  4011              ANDS     r1,r1,r2
                  |L12.16|
000010  6001              STR      r1,[r0,#0]            ;481
;;;487        }
;;;488    }
000012  4770              BX       lr
;;;489    
                          ENDP

                  |L12.20|
                          DCD      0x0000fffe

                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;397     */
;;;398    void TIM_ICInit ( TIM_TypeDef* TIMx, TIM_IC_InitTypeDef* TIM_IC_InitStruct )
000000  b510              PUSH     {r4,lr}
;;;399    {
;;;400        uint16_t tmpreg;
;;;401        /* Check the parameters */
;;;402    
;;;403    #if defined(SC32f10xx) || defined(SC32f12xx)
;;;404        if ( TIM_IC_InitStruct->TIM_FICPIN == TIM_FICPin_TnEx )
000002  884a              LDRH     r2,[r1,#2]
;;;405            assert_param ( IS_TIM_TNEX_PERIPH ( TIMx ) );
;;;406        if ( ( TIM_IC_InitStruct->TIM_FICPIN == TIM_FICPin_Tn ) ||
;;;407                ( TIM_IC_InitStruct->TIM_RICPIN == TIM_RICPin_Tn ) )
000004  880b              LDRH     r3,[r1,#0]
;;;408            assert_param ( IS_TIM_TN_PERIPH ( TIMx ) );
;;;409    
;;;410    #endif
;;;411    
;;;412    
;;;413        /* Get the TIMx TIM_CON register value */
;;;414        tmpreg = ( uint16_t ) TIMx->TIM_CON;
000006  6801              LDR      r1,[r0,#0]
;;;415    
;;;416        /* Clear EXENR, EXENF and EXENX SPR bits */
;;;417        tmpreg &= ~ ( TIM_CON_EXENR | TIM_CON_EXENF | TIM_CON_FSEL | TIM_CON_EXENX );
000008  243c              MOVS     r4,#0x3c
00000a  b289              UXTH     r1,r1                 ;414
00000c  43a1              BICS     r1,r1,r4
;;;418    
;;;419    
;;;420    #if defined(SC32f10xx)
;;;421        if ( TIMx == TIM0 )
;;;422        {
;;;423            if ( TIM_IC_InitStruct->TIM_FICPIN != TIM_FICPin_Tn )
;;;424            {
;;;425                tmpreg |= TIM_IC_InitStruct->TIM_FICPIN;
;;;426            }
;;;427    
;;;428        }
;;;429        else
;;;430        {
;;;431            tmpreg |= ( TIM_IC_InitStruct->TIM_FICPIN | TIM_IC_InitStruct->TIM_RICPIN );
;;;432        }
;;;433    #elif  defined(SC32f12xx) 
;;;434    
;;;435        tmpreg |= ( TIM_IC_InitStruct->TIM_FICPIN | TIM_IC_InitStruct->TIM_RICPIN );
00000e  431a              ORRS     r2,r2,r3
000010  430a              ORRS     r2,r2,r1
;;;436    #endif
;;;437    
;;;438    
;;;439        TIMx->TIM_CON = ( uint32_t ) tmpreg;
000012  6002              STR      r2,[r0,#0]
;;;440    }
000014  bd10              POP      {r4,pc}
;;;441    
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;446      */
;;;447    void TIM_ICStructInit ( TIM_IC_InitTypeDef* TIM_IC_InitStruct )
000000  2100              MOVS     r1,#0
;;;448    {
;;;449        /* Set the default configuration */
;;;450        TIM_IC_InitStruct->TIM_FICPIN = TIM_FICPin_Disable;
000002  8041              STRH     r1,[r0,#2]
;;;451        TIM_IC_InitStruct->TIM_RICPIN = TIM_RICPin_Disable;
000004  8001              STRH     r1,[r0,#0]
;;;452    }
000006  4770              BX       lr
;;;453    
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;859     */
;;;860    void TIM_ITConfig ( TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;861    {
;;;862        /* Check the parameters */
;;;863        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;864        assert_param ( IS_TIM_IT ( TIM_IT ) );
;;;865        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;866    
;;;867        if ( NewState != DISABLE )
;;;868        {
;;;869            /* Enable the Interrupt sources */
;;;870            TIMx->TIM_IDE |= TIM_IT;
;;;871        }
;;;872        else
;;;873        {
;;;874            /* Disable the Interrupt sources */
;;;875            TIMx->TIM_IDE &= ( uint16_t ) ~TIM_IT;
000002  6982              LDR      r2,[r0,#0x18]
000004  d001              BEQ      |L15.10|
000006  430a              ORRS     r2,r2,r1              ;870
000008  e002              B        |L15.16|
                  |L15.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L15.16|
000010  6182              STR      r2,[r0,#0x18]         ;870
;;;876        }
;;;877    }
000012  4770              BX       lr
;;;878    
                          ENDP


                          AREA ||i.TIM_PWMGetDuty||, CODE, READONLY, ALIGN=1

                  TIM_PWMGetDuty PROC
;;;702     */
;;;703    uint16_t TIM_PWMGetDuty ( TIM_TypeDef* TIMx, TIM_PWMChannel_Typedef TIM_PWMChannel )
000000  2902              CMP      r1,#2
;;;704    {
000002  d002              BEQ      |L16.10|
;;;705        uint16_t tmpduty = 0;
;;;706    
;;;707        /* Check the parameters */
;;;708        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;709    
;;;710        if ( TIM_PWMChannel == TIM_PWMChannel_PWMA )
;;;711        {
;;;712            tmpduty = ( uint16_t ) TIMx->TIM_PDTA_RCAP;
;;;713        }
;;;714        else
;;;715        {
;;;716            tmpduty = ( uint16_t ) TIMx->TIM_PDTB_FCAP;
000004  6940              LDR      r0,[r0,#0x14]
                  |L16.6|
000006  b280              UXTH     r0,r0                 ;712
;;;717        }
;;;718    
;;;719        return tmpduty;
;;;720    }
000008  4770              BX       lr
                  |L16.10|
00000a  6900              LDR      r0,[r0,#0x10]         ;712
00000c  e7fb              B        |L16.6|
;;;721    
                          ENDP


                          AREA ||i.TIM_PWMInit||, CODE, READONLY, ALIGN=1

                  TIM_PWMInit PROC
;;;569     */
;;;570    void TIM_PWMInit ( TIM_TypeDef* TIMx, TIM_PWM_InitTypeDef* TIM_PWM_InitStruct )
000000  b510              PUSH     {r4,lr}
;;;571    {
;;;572        uint32_t tmpreg;
;;;573        /* Check the parameters */
;;;574    #if defined(SC32f10xx) || defined(SC32f12xx)
;;;575        if ( ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl == TIM_PWMChannel_PWMA ) ||
000002  884a              LDRH     r2,[r1,#2]
;;;576                ( TIM_PWM_InitStruct->TIM_PWMOutputChannl == TIM_PWMChannel_PWMA ) )
000004  880b              LDRH     r3,[r1,#0]
;;;577            assert_param ( IS_TIM_TN_PERIPH ( TIMx ) );
;;;578        if ( ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl == TIM_PWMChannel_PWMB ) ||
;;;579                ( TIM_PWM_InitStruct->TIM_PWMOutputChannl == TIM_PWMChannel_PWMB ) )
;;;580            assert_param ( IS_TIM_TNEX_PERIPH ( TIMx ) );
;;;581    
;;;582    #endif
;;;583        /* Get the TIMx TIM_CON value */
;;;584        tmpreg = TIMx->TIM_CON;
000006  6801              LDR      r1,[r0,#0]
;;;585    
;;;586        /* Clear EPWMNA,EPWMNB,INVNA and INVNB bit */
;;;587        tmpreg &= ( uint32_t ) ~ ( TIM_CON_EPWMNA | TIM_CON_EPWMNB | TIM_CON_INVNA | TIM_CON_INVNB );
000008  240f              MOVS     r4,#0xf
00000a  02e4              LSLS     r4,r4,#11
;;;588    
;;;589        /* TIM0 has no TnPWMA and TIM1,2,3,4,5,6,7 has no TnPWMB */
;;;590    #if defined(SC32f10xx)
;;;591        /* TIM0 has no TnPWMA and TIM1,2,3,4,5,6,7 has no TnPWMB */
;;;592        if ( ( ( TIMx == TIM0 ) && ( TIM_PWM_InitStruct->TIM_PWMOutputChannl != TIM_PWMChannel_PWMA ) &&
;;;593                ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl != TIM_PWMChannel_PWMA ) ) ||
;;;594                ( ( TIMx != TIM0 ) && ( TIM_PWM_InitStruct->TIM_PWMOutputChannl != TIM_PWMChannel_PWMB ) &&
;;;595                  ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl != TIM_PWMChannel_PWMB ) ) )
;;;596        {
;;;597            /* Set EPWMNA and EPWMNB bit to PWM Output Channl value */
;;;598            /* Set INVNA and INVNB bit to PWM Low Polarity Channl value */
;;;599            tmpreg |= ( uint32_t ) ( ( TIM_PWM_InitStruct->TIM_PWMOutputChannl << ( 13U ) )
;;;600                                     | ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl ) << ( 11U ) );
;;;601        }
;;;602    #elif defined(SC32f12xx)
;;;603        {
;;;604            /* Set EPWMNA and EPWMNB bit to PWM Output Channl value */
;;;605            /* Set INVNA and INVNB bit to PWM Low Polarity Channl value */
;;;606            tmpreg |= ( uint32_t ) ( ( TIM_PWM_InitStruct->TIM_PWMOutputChannl << ( 13U ) )
00000c  035b              LSLS     r3,r3,#13
00000e  02d2              LSLS     r2,r2,#11
000010  43a1              BICS     r1,r1,r4              ;587
000012  4313              ORRS     r3,r3,r2
000014  430b              ORRS     r3,r3,r1
;;;607                                     | ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl ) << ( 11U ) );
;;;608        }
;;;609    
;;;610    #endif
;;;611    
;;;612        /* Write to TIMx TIM_CON */
;;;613        TIMx->TIM_CON = tmpreg;
000016  6003              STR      r3,[r0,#0]
;;;614    }
000018  bd10              POP      {r4,pc}
;;;615    
                          ENDP


                          AREA ||i.TIM_PWMSetDuty||, CODE, READONLY, ALIGN=1

                  TIM_PWMSetDuty PROC
;;;647     */
;;;648    void TIM_PWMSetDuty ( TIM_TypeDef* TIMx, TIM_PWMChannel_Typedef TIM_PWMChannel, uint16_t PWM_DutyValue )
000000  2902              CMP      r1,#2
;;;649    {
000002  d003              BEQ      |L18.12|
;;;650    #if defined(SC32f10xx)
;;;651        /* Check the parameters */
;;;652        if ( TIM_PWMChannel == TIM_PWMChannel_PWMA )
;;;653            assert_param ( IS_TIM_TN_PERIPH ( TIMx ) );
;;;654        if ( TIM_PWMChannel == TIM_PWMChannel_PWMB )
;;;655            assert_param ( IS_TIM_TNEX_PERIPH ( TIMx ) );
;;;656    
;;;657        /* TIM0 has no TnPWMA */
;;;658        if ( ( TIMx != TIM0 ) && ( TIM_PWMChannel == TIM_PWMChannel_PWMA ) )
;;;659        {
;;;660            TIMx->TIM_PDTA_RCAP = PWM_DutyValue;
;;;661        }
;;;662        /* TIM1,2,3,4,5,6,7 has no TnPWMB */
;;;663        else if ( ( TIMx == TIM0 ) && ( TIM_PWMChannel == TIM_PWMChannel_PWMB ) )
;;;664        {
;;;665            TIMx->TIM_PDTB_FCAP = PWM_DutyValue;
;;;666        }
;;;667    #elif  defined(SC32f12xx)
;;;668        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;669    
;;;670        if ( TIM_PWMChannel == TIM_PWMChannel_PWMA )
;;;671        {
;;;672            TIMx->TIM_PDTA_RCAP = PWM_DutyValue;
;;;673        }
;;;674        else if ( TIM_PWMChannel == TIM_PWMChannel_PWMB )
000004  2901              CMP      r1,#1
000006  d100              BNE      |L18.10|
;;;675        {
;;;676            TIMx->TIM_PDTB_FCAP = PWM_DutyValue;
000008  6142              STR      r2,[r0,#0x14]
                  |L18.10|
;;;677        }
;;;678    
;;;679    #endif
;;;680    
;;;681    
;;;682    }
00000a  4770              BX       lr
                  |L18.12|
00000c  6102              STR      r2,[r0,#0x10]         ;672
00000e  4770              BX       lr
;;;683    
                          ENDP


                          AREA ||i.TIM_PWMStructInit||, CODE, READONLY, ALIGN=1

                  TIM_PWMStructInit PROC
;;;620      */
;;;621    void TIM_PWMStructInit ( TIM_PWM_InitTypeDef* TIM_PWM_InitStruct )
000000  2100              MOVS     r1,#0
;;;622    {
;;;623        /* Set the default configuration */
;;;624        TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl = TIM_PWMChannel_Less;
000002  8041              STRH     r1,[r0,#2]
;;;625        TIM_PWM_InitStruct->TIM_PWMOutputChannl = TIM_PWMChannel_Less;
000004  8001              STRH     r1,[r0,#0]
;;;626    }
000006  4770              BX       lr
;;;627    
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;263     */
;;;264    void TIM_SetAutoreload ( TIM_TypeDef* TIMx, uint16_t Autoreload )
000000  6081              STR      r1,[r0,#8]
;;;265    {
;;;266        /* Check the parameters */
;;;267        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;268    
;;;269        /* Set the ReloadData Register value */
;;;270        TIMx->TIM_RLD = Autoreload;
;;;271    }
000002  4770              BX       lr
;;;272    
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;214     */
;;;215    void TIM_SetCounter ( TIM_TypeDef* TIMx, uint32_t Counter )
000000  6041              STR      r1,[r0,#4]
;;;216    {
;;;217        /* Check the parameters */
;;;218        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;219    
;;;220        /* Set the Counter Register value */
;;;221        TIMx->TIM_CNT = ( uint32_t ) Counter;
;;;222    }
000002  4770              BX       lr
;;;223    
                          ENDP


                          AREA ||i.TIM_SetPerscaler||, CODE, READONLY, ALIGN=1

                  TIM_SetPerscaler PROC
;;;320     */
;;;321    void TIM_SetPerscaler ( TIM_TypeDef* TIMx, TIM_Prescaler_TypeDef TIM_Perscaler )
000000  6802              LDR      r2,[r0,#0]
;;;322    {
;;;323    
;;;324        /* Check the parameters */
;;;325        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;326        assert_param ( IS_TIM_PRESCALER ( TIM_Perscaler ) );
;;;327    
;;;328        /* Reset the CKD Bits */
;;;329        TIMx->TIM_CON &= ( uint32_t ) ( ~TIM_CON_TIMCLK );
000002  2307              MOVS     r3,#7
000004  021b              LSLS     r3,r3,#8
000006  439a              BICS     r2,r2,r3
000008  6002              STR      r2,[r0,#0]
;;;330    
;;;331        /* Set the CKD value */
;;;332        TIMx->TIM_CON |= TIM_Perscaler;
00000a  6802              LDR      r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  6002              STR      r2,[r0,#0]
;;;333    }
000010  4770              BX       lr
;;;334    
                          ENDP


                          AREA ||i.TIM_TIMBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TIMBaseInit PROC
;;;118     */
;;;119    void TIM_TIMBaseInit ( TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct )
000000  b530              PUSH     {r4,r5,lr}
;;;120    {
;;;121        /* Check the parameters */
;;;122        uint32_t tmpreg;
;;;123        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;124        assert_param ( IS_TIM_PRESCALER ( TIM_TimeBaseInitStruct->TIM_EXENX ) );
;;;125        assert_param ( IS_TIM_WORKMODE ( TIM_TimeBaseInitStruct->TIM_WorkMode ) );
;;;126        assert_param ( IS_TIM_COUNTERMODE ( TIM_TimeBaseInitStruct->TIM_CounterMode ) );
;;;127        assert_param ( IS_TIM_RICPin ( TIM_TimeBaseInitStruct->TIM_Prescaler ) );
;;;128    
;;;129        /*---------------------------- TIMx TIM_CON Configuration ------------------------*/
;;;130        /* Get the TIMx TIM_CON value */
;;;131        tmpreg = TIMx->TIM_CON;
000002  6802              LDR      r2,[r0,#0]
;;;132        /* Clear TIMCK, DEC, CTSEL and EXENX SPR bits */
;;;133        tmpreg &= ( uint32_t ) ~ ( TIM_CON_TIMCLK | TIM_CON_CTSEL | TIM_CON_DEC | TIM_CON_EXENX );
000004  4b07              LDR      r3,|L23.36|
;;;134        /* Configure TIMx: Prescaler, AlignedMode and WorkMode */
;;;135        /* Set TIMCK bits according to Prescaler value */
;;;136        /* Set DEC bit according to CounterMode value */
;;;137        /* Set CTSEL bit according to WorkMode value */
;;;138        /* Set EXENX bit according to EXENX value */
;;;139        tmpreg |= ( uint32_t ) ( TIM_TimeBaseInitStruct->TIM_Prescaler | TIM_TimeBaseInitStruct->TIM_CounterMode |
000006  888c              LDRH     r4,[r1,#4]
000008  401a              ANDS     r2,r2,r3              ;133
00000a  880b              LDRH     r3,[r1,#0]
00000c  88cd              LDRH     r5,[r1,#6]
00000e  4323              ORRS     r3,r3,r4
000010  884c              LDRH     r4,[r1,#2]
000012  432c              ORRS     r4,r4,r5
000014  4323              ORRS     r3,r3,r4
000016  4313              ORRS     r3,r3,r2
;;;140                                 TIM_TimeBaseInitStruct->TIM_WorkMode | ( TIM_TimeBaseInitStruct->TIM_EXENX ) );
;;;141        /* Write to TIMx TIM_CON */
;;;142        TIMx->TIM_CON = tmpreg;
000018  6003              STR      r3,[r0,#0]
;;;143        /* Write to TIMx TIM_CYCLE */
;;;144        TIMx->TIM_CNT = TIMx->TIM_RLD = TIM_TimeBaseInitStruct->TIM_Preload;
00001a  8909              LDRH     r1,[r1,#8]
00001c  6081              STR      r1,[r0,#8]
00001e  6041              STR      r1,[r0,#4]
;;;145    
;;;146    }
000020  bd30              POP      {r4,r5,pc}
;;;147    
                          ENDP

000022  0000              DCW      0x0000
                  |L23.36|
                          DCD      0xfffff89d

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;152      */
;;;153    void TIM_TimeBaseStructInit ( TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct )
000000  2100              MOVS     r1,#0
;;;154    {
;;;155        /* Set the default configuration */
;;;156        TIM_TimeBaseInitStruct->TIM_Prescaler = TIM_PRESCALER_1;
000002  8001              STRH     r1,[r0,#0]
;;;157        TIM_TimeBaseInitStruct->TIM_WorkMode = TIM_WorkMode_Timer;
000004  8041              STRH     r1,[r0,#2]
;;;158        TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
000006  8081              STRH     r1,[r0,#4]
;;;159        TIM_TimeBaseInitStruct->TIM_Preload = 0x0000;
000008  8101              STRH     r1,[r0,#8]
;;;160        TIM_TimeBaseInitStruct->TIM_EXENX = TIM_EXENX_Disable;
00000a  80c1              STRH     r1,[r0,#6]
;;;161    }
00000c  4770              BX       lr
;;;162    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_tim_c_c458916b____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_tim_c_c458916b____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_tim_c_c458916b____REVSH|
#line 478
|__asm___15_sc32f1xxx_tim_c_c458916b____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
