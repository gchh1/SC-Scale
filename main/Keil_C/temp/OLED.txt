// #include "sc32f12xx.h"                  // Device header
// #include "OLED_Font.h"
// #include "sc32f1xxx_gpio.h"
// #include "string.h"

// uint8_t Data_Null[32] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// 	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,};


// /*引脚配置*/
// #define OLED_W_SCL(x)		GPIO_WriteBit(GPIOB, GPIO_Pin_11, (BitAction)(x))
// #define OLED_W_SDA(x)		GPIO_WriteBit(GPIOB, GPIO_Pin_12, (BitAction)(x))

// /*引脚初始化*/
// void OLED_I2C_Init(void)
// {
	
// 	GPIO_InitTypeDef GPIO_InitStructure;
//  	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT_PP;
// 	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
//  	GPIO_Init(GPIOB, &GPIO_InitStructure);
// 	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
//  	GPIO_Init(GPIOB, &GPIO_InitStructure);
	
// 	OLED_W_SCL(1);
// 	OLED_W_SDA(1);
// }

// /**
//   * @brief  I2C开始
//   * @param  无
//   * @retval 无
//   */
// void OLED_I2C_Start(void)
// {
// 	OLED_W_SDA(1);
// 	OLED_W_SCL(1);
// 	OLED_W_SDA(0);
// 	OLED_W_SCL(0);
// }

// /**
//   * @brief  I2C停止
//   * @param  无
//   * @retval 无
//   */
// void OLED_I2C_Stop(void)
// {
// 	OLED_W_SDA(0);
// 	OLED_W_SCL(1);
// 	OLED_W_SDA(1);
// }

// /**
//   * @brief  I2C发送一个字节
//   * @param  Byte 要发送的一个字节
//   * @retval 无
//   */
// void OLED_I2C_SendByte(uint8_t Byte)
// {
// 	uint8_t i;
// 	for (i = 0; i < 8; i++)
// 	{
// 		OLED_W_SDA(!!(Byte & (0x80 >> i)));
// 		OLED_W_SCL(1);
// 		OLED_W_SCL(0);
// 	}
// 	OLED_W_SCL(1);	//额外的一个时钟，不处理应答信号
// 	OLED_W_SCL(0);
// }

// /**
//   * @brief  OLED写命令
//   * @param  Command 要写入的命令
//   * @retval 无
//   */
// void OLED_WriteCommand(uint8_t Command)
// {
// 	OLED_I2C_Start();
// 	OLED_I2C_SendByte(0x78);		//从机地址
// 	OLED_I2C_SendByte(0x00);		//写命令
// 	OLED_I2C_SendByte(Command); 
// 	OLED_I2C_Stop();
// }

// /**
//   * @brief  OLED写数据
//   * @param  Data 要写入的数据
//   * @retval 无
//   */
// void OLED_WriteData(uint8_t Data)
// {
// 	OLED_I2C_Start();
// 	OLED_I2C_SendByte(0x78);		//从机地址
// 	OLED_I2C_SendByte(0x40);		//写数据
// 	OLED_I2C_SendByte(Data);
// 	OLED_I2C_Stop();
// }

// /**
//   * @brief  OLED设置光标位置
//   * @param  Y 以左上角为原点，向下方向的坐标，范围：0~7
//   * @param  X 以左上角为原点，向右方向的坐标，范围：0~127
//   * @retval 无
//   */
// void OLED_SetCursor(uint8_t Y, uint8_t X)
// {
// 	OLED_WriteCommand(0xB0 | Y);					//设置Y位置
// 	OLED_WriteCommand(0x10 | ((X & 0xF0) >> 4));	//设置X位置高4位
// 	OLED_WriteCommand(0x00 | (X & 0x0F));			//设置X位置低4位
// }

// /**
//   * @brief  OLED清屏
//   * @param  无
//   * @retval 无
//   */
// void _OLED_Clear(void)
// {  
// 	uint8_t i, j;
// 	for (j = 0; j < 8; j++)
// 	{
// 		OLED_SetCursor(j, 0);
// 		for(i = 0; i < 128; i++)
// 		{
// 			OLED_WriteData(0x00);
// 		}
// 	}
// }

// /**
//   * @brief  OLED显示一个字符
//   * @param  Line 行位置，范围：1~4
//   * @param  Column 列位置，范围：1~16
//   * @param  Char 要显示的一个字符，范围：ASCII可见字符
//   * @retval 无
//   */
// void OLED_ShowChar(uint8_t Line, uint8_t Column, char Char)
// {      	
// 	uint8_t i;
// 	OLED_SetCursor((Line - 1) * 2, (Column - 1) * 8);		//设置光标位置在上半部分
// 	for (i = 0; i < 8; i++)
// 	{
// 		OLED_WriteData(OLED_F8x16[Char - ' '][i]);			//显示上半部分内容
// 	}
// 	OLED_SetCursor((Line - 1) * 2 + 1, (Column - 1) * 8);	//设置光标位置在下半部分
// 	for (i = 0; i < 8; i++)
// 	{
// 		OLED_WriteData(OLED_F8x16[Char - ' '][i + 8]);		//显示下半部分内容
// 	}
// }

// /**
//   * @brief  OLED显示字符串
//   * @param  Line 起始行位置，范围：1~4
//   * @param  Column 起始列位置，范围：1~16
//   * @param  String 要显示的字符串，范围：ASCII可见字符
//   * @retval 无
//   */
// void OLED_ShowString(uint8_t Line, uint8_t Column, char *String)
// {
// 	uint8_t i;
// 	for (i = 0; String[i] != '\0'; i++)
// 	{
// 		OLED_ShowChar(Line, Column + i, String[i]);
// 	}
// }

// /**
//   * @brief  OLED次方函数
//   * @retval 返回值等于X的Y次方
//   */
// uint32_t OLED_Pow(uint32_t X, uint32_t Y)
// {
// 	uint32_t Result = 1;
// 	while (Y--)
// 	{
// 		Result *= X;
// 	}
// 	return Result;
// }

// /**
//   * @brief  OLED显示数字（十进制，正数）
//   * @param  Line 起始行位置，范围：1~4
//   * @param  Column 起始列位置，范围：1~16
//   * @param  Number 要显示的数字，范围：0~4294967295
//   * @param  Length 要显示数字的长度，范围：1~10
//   * @retval 无
//   */
// void OLED_ShowNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length)
// {
// 	uint8_t i;
// 	uint8_t digits = 0;
// 	uint32_t temp = Number;
	
// 	if (Number == 0) {
// 		digits = 1;
// 	} else {
// 		uint32_t n = Number;
// 		while (n > 0 && digits < Length) {
// 			n /= 10;
// 			digits++;
// 		}
// 	}
	
// 	if (digits > Length) {
// 		digits = Length;
// 	}
	
// 	// Fill the number position with space
// 	for (i = 0; i < Length; i++)
//     {
//         OLED_ShowChar(Line, Column + i, ' '); 
//     }
	
// 	for (i = 0; i < digits; i++) {
// 		uint8_t digit = temp % 10;
// 		OLED_ShowChar(Line, Column + Length - 1 - i, digit + '0');
// 		temp /= 10;
// 	}
// }

// /**
//   * @brief  OLED显示数字（十进制，带符号数）
//   * @param  Line 起始行位置，范围：1~4
//   * @param  Column 起始列位置，范围：1~16
//   * @param  Number 要显示的数字，范围：-2147483648~2147483647
//   * @param  Length 要显示数字的长度，范围：1~10
//   * @retval 无
//   */
// void OLED_ShowSignedNum(uint8_t Line, uint8_t Column, int32_t Number, uint8_t Length)
// {
// 	uint8_t i;
// 	uint32_t Number1;
// 	if (Number >= 0)
// 	{
// 		OLED_ShowChar(Line, Column, '+');
// 		Number1 = Number;
// 	}
// 	else
// 	{
// 		OLED_ShowChar(Line, Column, '-');
// 		Number1 = -Number;
// 	}
// 	for (i = 0; i < Length; i++)							
// 	{
// 		OLED_ShowChar(Line, Column + i + 1, Number1 / OLED_Pow(10, Length - i - 1) % 10 + '0');
// 	}
// }

// /**
//  * @brief  OLED显示浮点数
//  * @param  Line 起始行位置，范围：1~4
//  * @param  Column 起始列位置，范围：1~16
//  * @param  Number 要显示的数字，范围：-2147483648.0 ~ 2147483647.0
//  * @param  Length 数字整体长度 
//  * @param  DecLength 小数部分的显示长度
//  * @retval 无
//  */
// void OLED_ShowFloat(uint8_t Line, uint8_t Column, float Number, uint8_t Length, uint8_t DecLength)
// {
//     uint32_t IntPart;
//     uint32_t DecPart;
// 	uint8_t IntLength = 0;
//     uint8_t i;

// 	//* Get the digit of the number include the dot and dec 
// 	if (Number == 0) {
// 		IntLength = 1;
// 	} else {
// 		float n = Number;
// 		while (n > 0) {
// 			n /= 10;
// 			IntLength++;
// 		}
// 	}

// 	//* Fill the number place with space
// 	for (i = 0; i < Length; i++) {
// 		OLED_ShowChar(Line, Column + i, ' ');
// 	}
    
// 	//* Handle negative
// 	if (Number < 0) {
// 		OLED_ShowChar(Line, Column + Length - DecLength - IntLength - 1, '-');
// 		Number = -Number;
// 	}

//     //* 提取整数部分
//     IntPart = (uint32_t)Number;
    
//     //* 提取小数部分 (利用乘法移位，并加0.5进行四舍五入防止精度截断)
//     DecPart = (uint32_t)((Number - IntPart) * OLED_Pow(10, DecLength) + 0.5);

//     //* 显示整数部分 (复用你现有的ShowNum)
// 	OLED_ShowNum(Line, Column + Length - 1 - DecLength - IntLength, IntPart, IntLength);

//     //* 显示小数点
//     OLED_ShowChar(Line, Column + Length - 1 - DecLength, '.');

//     //* 显示小数部分
// 	uint8_t digit;
// 	for (i = 0; i < DecLength; i++) {
// 		digit = DecPart % 10;
// 		OLED_ShowChar(Line, Column + Length - i - 1, '0' + digit);
// 		DecPart /= 10;
// 	}
// }

// /**
//   * @brief  OLED显示一个中文
//   * @param  Line 行位置，范围：1~4
//   * @param  Column 列位置，范围：1~8
//   * @param  Char 要显示的一个中文字符
//   * @retval 无
//   */
// void OLED_ShowChinese(uint8_t Line, uint8_t Column, char *Chinese)
// {    
// 	uint8_t array_num = sizeof(OLED_CF16x16)/sizeof(OLED_CF16x16[0]);
// 	uint8_t len = strlen(Chinese);
// 	uint8_t i,j,pindex;
// 	char SingleChinese[OLED_CHN_CHAR_WIDTH + 1] = {'\0'};

	
// 	for (i = 0; i < len/3; i ++)		//遍历汉字串
// 	{
// 		memcpy(SingleChinese,Chinese+i*3,3);
// 		for(pindex = 0; pindex < array_num; pindex++)
// 		{
			
// 			if(strcmp(OLED_CF16x16[pindex].Index,SingleChinese)==0)
// 			{
// 				OLED_SetCursor((Line - 1) * 2, (Column - 1) * 16);		//设置光标位置在上半部分
// 				for (j = 0; j < 16; j++)
// 				{
// 					OLED_WriteData(OLED_CF16x16[pindex].Data[j]);			//显示上半部分内容
// 				}
// 				OLED_SetCursor((Line - 1) * 2 + 1, (Column - 1) * 16);	//设置光标位置在下半部分
// 				for (j = 0;  j< 16; j++)
// 				{
// 					OLED_WriteData(OLED_CF16x16[pindex].Data[j+16]);		//显示下半部分内容
// 				}
// 				Column++;
// 				break;
// 			}
			
// 		}
// 		if(pindex == array_num)
// 			{
// 				OLED_SetCursor((Line - 1) * 2, (Column - 1) * 16);		//设置光标位置在上半部分
// 				for (j = 0; j < 16; j++)
// 				{
// 					OLED_WriteData(Data_Null[j]);			//显示上半部分内容
// 				}
// 				OLED_SetCursor((Line - 1) * 2 + 1, (Column - 1) * 16);	//设置光标位置在下半部分
// 				for (j = 0;  j< 16; j++)
// 				{
// 					OLED_WriteData(Data_Null[j+16]);		//显示下半部分内容
// 				}
// 				Column++;
			
// 			}
// 	}
	
// }

// /**
//   * @brief  OLED显示中文，并清除指定长度内多余的字符（防止重影）
//   * @param  Line 行位置，范围：1~4
//   * @param  Column 起始列位置，范围：1~8（每个单位代表16像素宽）
//   * @param  Length 要显示的区域总长度（单位：汉字个数）。
//   * 例如：如果显示"你好"，Length传4，则显示"你好  "，后两位会被清空。
//   * @param  Chinese 要显示的中文字符串
//   * @retval 无
//   */
// void OLED_ShowChinese2(uint8_t Line, uint8_t Column, uint8_t Length, char *Chinese)
// {
//     uint8_t i, j;
//     uint8_t used_cnt = strlen(Chinese) / 3; // 计算实际的中文字符个数 (UTF-8通常占3字节，GBK占2字节，根据你原代码这里是/3)

//     // 1. 先显示传入的中文字符串
//     OLED_ShowChinese(Line, Column, Chinese);

//     // 2. 遍历剩余的长度，将多余的位置清空 (填充0x00)
//     // 从 used_cnt 开始，直到达到预设的 Length
//     for (i = used_cnt; i < Length; i++)
//     {
//         /* 计算当前要清除的列的像素偏移量 
//            原逻辑中：(Column - 1) * 16 是起始像素
//            偏移 i 个汉字位置，即偏移 i * 16 像素
//         */
//         uint8_t current_col_idx = Column + i; 

//         // === 清除上半部分 (16x8) ===
//         OLED_SetCursor((Line - 1) * 2, (current_col_idx - 1) * 16);
//         for (j = 0; j < 16; j++)
//         {
//             OLED_WriteData(0x00); // 写入0，即熄灭像素
//         }

//         // === 清除下半部分 (16x8) ===
//         OLED_SetCursor((Line - 1) * 2 + 1, (current_col_idx - 1) * 16);
//         for (j = 0; j < 16; j++)
//         {
//             OLED_WriteData(0x00); // 写入0，即熄灭像素
//         }
//     }
// }

// /**
//   * @brief  OLED初始化
//   * @param  无
//   * @retval 无
//   */
// void _OLED_Init(void)
// {
// 	uint32_t i, j;
	
// 	for (i = 0; i < 1000; i++)			//上电延时
// 	{
// 		for (j = 0; j < 1000; j++);
// 	}
	
// 	OLED_I2C_Init();			//端口初始化
	
// 	OLED_WriteCommand(0xAE);	//关闭显示
	
// 	OLED_WriteCommand(0xD5);	//设置显示时钟分频比/振荡器频率
// 	OLED_WriteCommand(0x80);
	
// 	OLED_WriteCommand(0xA8);	//设置多路复用率
// 	OLED_WriteCommand(0x3F);
	
// 	OLED_WriteCommand(0xD3);	//设置显示偏移
// 	OLED_WriteCommand(0x00);
	
// 	OLED_WriteCommand(0x40);	//设置显示开始行
	
// 	OLED_WriteCommand(0xA1);	//设置左右方向，0xA1正常 0xA0左右反置
	
// 	OLED_WriteCommand(0xC8);	//设置上下方向，0xC8正常 0xC0上下反置

// 	OLED_WriteCommand(0xDA);	//设置COM引脚硬件配置
// 	OLED_WriteCommand(0x12);
	
// 	OLED_WriteCommand(0x81);	//设置对比度控制
// 	OLED_WriteCommand(0xCF);

// 	OLED_WriteCommand(0xD9);	//设置预充电周期
// 	OLED_WriteCommand(0xF1);

// 	OLED_WriteCommand(0xDB);	//设置VCOMH取消选择级别
// 	OLED_WriteCommand(0x30);

// 	OLED_WriteCommand(0xA4);	//设置整个显示打开/关闭

// 	OLED_WriteCommand(0xA6);	//设置正常/倒转显示

// 	OLED_WriteCommand(0x8D);	//设置充电泵
// 	OLED_WriteCommand(0x14);

// 	OLED_WriteCommand(0xAF);	//开启显示
		
// 	_OLED_Clear();				//OLED清屏
// }




// /**
//  * @brief  OLED显示浮点数
//  * @param  Line 起始行位置，范围：1~4
//  * @param  Column 起始列位置，范围：1~16
//  * @param  Number 要显示的数字，范围：-2147483648.0 ~ 2147483647.0
//  * @param  Length 数字整体长度 
//  * @param  DecLength 小数部分的显示长度
//  * @retval 无
//  */
// void OLED_ShowFloat(uint8_t Line, uint8_t Column, float Number, uint8_t Length, uint8_t DecLength)
// {
//     uint32_t IntPart;
//     uint32_t DecPart;
// 	uint8_t IntLength = 0;
//     uint8_t i;

// 	//* Get the digit of the number include the dot and dec 
// 	if (Number == 0) {
// 		IntLength = 1;
// 	} else {
// 		float n = Number;
// 		while (n > 0) {
// 			n /= 10;
// 			IntLength++;
// 		}
// 	}

// 	//* Fill the number place with space
// 	for (i = 0; i < Length; i++) {
// 		OLED_ShowChar(Line, Column + i, ' ');
// 	}
    
// 	//* Handle negative
// 	if (Number < 0) {
// 		OLED_ShowChar(Line, Column + Length - DecLength - IntLength - 1, '-');
// 		Number = -Number;
// 	}

//     //* 提取整数部分
//     IntPart = (uint32_t)Number;
    
//     //* 提取小数部分 (利用乘法移位，并加0.5进行四舍五入防止精度截断)
//     DecPart = (uint32_t)((Number - IntPart) * OLED_Pow(10, DecLength) + 0.5);

//     //* 显示整数部分 (复用你现有的ShowNum)
// 	OLED_ShowNum(Line, Column + Length - 1 - DecLength - IntLength, IntPart, IntLength);

//     //* 显示小数点
//     OLED_ShowChar(Line, Column + Length - 1 - DecLength, '.');

//     //* 显示小数部分
// 	uint8_t digit;
// 	for (i = 0; i < DecLength; i++) {
// 		digit = DecPart % 10;
// 		OLED_ShowChar(Line, Column + Length - i - 1, '0' + digit);
// 		DecPart /= 10;
// 	}
// }

// /**
//   * @brief  OLED显示一个中文
//   * @param  Line 行位置，范围：1~4
//   * @param  Column 列位置，范围：1~8
//   * @param  Char 要显示的一个中文字符
//   * @retval 无
//   */
// void OLED_ShowChinese(uint8_t Line, uint8_t Column, char *Chinese)
// {    
// 	uint8_t array_num = sizeof(OLED_CF16x16)/sizeof(OLED_CF16x16[0]);
// 	uint8_t len = strlen(Chinese);
// 	uint8_t i,j,pindex;
// 	char SingleChinese[OLED_CHN_CHAR_WIDTH + 1] = {'\0'};

	
// 	for (i = 0; i < len/3; i ++)		//遍历汉字串
// 	{
// 		memcpy(SingleChinese,Chinese+i*3,3);
// 		for(pindex = 0; pindex < array_num; pindex++)
// 		{
			
// 			if(strcmp(OLED_CF16x16[pindex].Index,SingleChinese)==0)
// 			{
// 				OLED_SetCursor((Line - 1) * 2, (Column - 1) * 16);		//设置光标位置在上半部分
// 				for (j = 0; j < 16; j++)
// 				{
// 					OLED_WriteData(OLED_CF16x16[pindex].Data[j]);			//显示上半部分内容
// 				}
// 				OLED_SetCursor((Line - 1) * 2 + 1, (Column - 1) * 16);	//设置光标位置在下半部分
// 				for (j = 0;  j< 16; j++)
// 				{
// 					OLED_WriteData(OLED_CF16x16[pindex].Data[j+16]);		//显示下半部分内容
// 				}
// 				Column++;
// 				break;
// 			}
			
// 		}
// 		if(pindex == array_num)
// 			{
// 				OLED_SetCursor((Line - 1) * 2, (Column - 1) * 16);		//设置光标位置在上半部分
// 				for (j = 0; j < 16; j++)
// 				{
// 					OLED_WriteData(Data_Null[j]);			//显示上半部分内容
// 				}
// 				OLED_SetCursor((Line - 1) * 2 + 1, (Column - 1) * 16);	//设置光标位置在下半部分
// 				for (j = 0;  j< 16; j++)
// 				{
// 					OLED_WriteData(Data_Null[j+16]);		//显示下半部分内容
// 				}
// 				Column++;
			
// 			}
// 	}
	
// }

// /**
//   * @brief  OLED显示中文，并清除指定长度内多余的字符（防止重影）
//   * @param  Line 行位置，范围：1~4
//   * @param  Column 起始列位置，范围：1~8（每个单位代表16像素宽）
//   * @param  Length 要显示的区域总长度（单位：汉字个数）。
//   * 例如：如果显示"你好"，Length传4，则显示"你好  "，后两位会被清空。
//   * @param  Chinese 要显示的中文字符串
//   * @retval 无
//   */
// void OLED_ShowChinese2(uint8_t Line, uint8_t Column, uint8_t Length, char *Chinese)
// {
//     uint8_t i, j;
//     uint8_t used_cnt = strlen(Chinese) / 3; // 计算实际的中文字符个数 (UTF-8通常占3字节，根据原代码这里是/3)

//     // 1. 先显示传入的中文字符串
//     OLED_ShowChinese(Line, Column, Chinese);

//     // 2. 遍历剩余的长度，将多余的位置清空 (填充0x00)
//     for (i = used_cnt; i < Length; i++)
//     {
//         uint8_t current_col_idx = Column + i; 

//         // === 清除上半部分 (16x8) ===
//         OLED_SetCursor((Line - 1) * 2, (current_col_idx - 1) * 16);
//         for (j = 0; j < 16; j++)
//         {
//             OLED_WriteData(0x00); // 写入0，即熄灭像素
//         }

//         // === 清除下半部分 (16x8) ===
//         OLED_SetCursor((Line - 1) * 2 + 1, (current_col_idx - 1) * 16);
//         for (j = 0; j < 16; j++)
//         {
//             OLED_WriteData(0x00); // 写入0，即熄灭像素
//         }
//     }
// }